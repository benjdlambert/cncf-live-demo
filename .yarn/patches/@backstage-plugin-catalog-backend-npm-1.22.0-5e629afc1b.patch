diff --git a/dist/cjs/CatalogBuilder-g0TDave-.cjs.js b/dist/cjs/CatalogBuilder-g0TDave-.cjs.js
index 2bfa6ffb0c9dc14d8916749c1413bb9fe61456a6..7cb2fb258aa10e4ac98a70b1e82b10a96ebae720 100644
--- a/dist/cjs/CatalogBuilder-g0TDave-.cjs.js
+++ b/dist/cjs/CatalogBuilder-g0TDave-.cjs.js
@@ -1,53 +1,63 @@
-'use strict';
+"use strict";
 
-var backendCommon = require('@backstage/backend-common');
-var catalogModel = require('@backstage/catalog-model');
-var integration = require('@backstage/integration');
-var crypto = require('crypto');
-var lodash = require('lodash');
-var errors = require('@backstage/errors');
-require('core-js/features/promise');
-var codeowners = require('codeowners-utils');
-var parseGitUrl = require('git-url-parse');
-var pluginCatalogNode = require('@backstage/plugin-catalog-node');
-var fs = require('fs-extra');
-var g = require('glob');
-var path = require('path');
-var util = require('util');
-var yaml = require('yaml');
-var limiterFactory = require('p-limit');
-var uuid = require('uuid');
-var luxon = require('luxon');
-var promClient = require('prom-client');
-var api = require('@opentelemetry/api');
-var stableStringify = require('fast-json-stable-stringify');
-var backendPluginApi = require('@backstage/backend-plugin-api');
-var uniq = require('lodash/uniq');
-var splitToChunks = require('lodash/chunk');
-var zod = require('zod');
-var types = require('@backstage/types');
-var catalogClient = require('@backstage/catalog-client');
-var yn = require('yn');
-var backendOpenapiUtils = require('@backstage/backend-openapi-utils');
-var alpha = require('@backstage/plugin-catalog-common/alpha');
-var pluginPermissionCommon = require('@backstage/plugin-permission-common');
-var minimatch = require('minimatch');
-var config = require('@backstage/config');
-var pluginPermissionNode = require('@backstage/plugin-permission-node');
+var backendCommon = require("@backstage/backend-common");
+var catalogModel = require("@backstage/catalog-model");
+var integration = require("@backstage/integration");
+var crypto = require("crypto");
+var lodash = require("lodash");
+var errors = require("@backstage/errors");
+require("core-js/features/promise");
+var codeowners = require("codeowners-utils");
+var parseGitUrl = require("git-url-parse");
+var pluginCatalogNode = require("@backstage/plugin-catalog-node");
+var fs = require("fs-extra");
+var g = require("glob");
+var path = require("path");
+var util = require("util");
+var yaml = require("yaml");
+var limiterFactory = require("p-limit");
+var uuid = require("uuid");
+var luxon = require("luxon");
+var promClient = require("prom-client");
+var api = require("@opentelemetry/api");
+var stableStringify = require("fast-json-stable-stringify");
+var backendPluginApi = require("@backstage/backend-plugin-api");
+var uniq = require("lodash/uniq");
+var splitToChunks = require("lodash/chunk");
+var zod = require("zod");
+var types = require("@backstage/types");
+var catalogClient = require("@backstage/catalog-client");
+var yn = require("yn");
+var backendOpenapiUtils = require("@backstage/backend-openapi-utils");
+var alpha = require("@backstage/plugin-catalog-common/alpha");
+var pluginPermissionCommon = require("@backstage/plugin-permission-common");
+var minimatch = require("minimatch");
+var config = require("@backstage/config");
+var pluginPermissionNode = require("@backstage/plugin-permission-node");
 
-function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }
+function _interopDefaultCompat(e) {
+  return e && typeof e === "object" && "default" in e ? e : { default: e };
+}
 
 function _interopNamespaceCompat(e) {
-  if (e && typeof e === 'object' && 'default' in e) return e;
+  if (e && typeof e === "object" && "default" in e) return e;
   var n = Object.create(null);
   if (e) {
     Object.keys(e).forEach(function (k) {
-      if (k !== 'default') {
+      if (k !== "default") {
         var d = Object.getOwnPropertyDescriptor(e, k);
-        Object.defineProperty(n, k, d.get ? d : {
-          enumerable: true,
-          get: function () { return e[k]; }
-        });
+        Object.defineProperty(
+          n,
+          k,
+          d.get
+            ? d
+            : {
+                enumerable: true,
+                get: function () {
+                  return e[k];
+                },
+              }
+        );
       }
     });
   }
@@ -55,18 +65,20 @@ function _interopNamespaceCompat(e) {
   return Object.freeze(n);
 }
 
-var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);
-var codeowners__namespace = /*#__PURE__*/_interopNamespaceCompat(codeowners);
-var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);
-var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
-var g__default = /*#__PURE__*/_interopDefaultCompat(g);
-var path__default = /*#__PURE__*/_interopDefaultCompat(path);
-var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);
-var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);
-var stableStringify__default = /*#__PURE__*/_interopDefaultCompat(stableStringify);
-var uniq__default = /*#__PURE__*/_interopDefaultCompat(uniq);
-var splitToChunks__default = /*#__PURE__*/_interopDefaultCompat(splitToChunks);
-var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);
+var lodash__default = /*#__PURE__*/ _interopDefaultCompat(lodash);
+var codeowners__namespace = /*#__PURE__*/ _interopNamespaceCompat(codeowners);
+var parseGitUrl__default = /*#__PURE__*/ _interopDefaultCompat(parseGitUrl);
+var fs__default = /*#__PURE__*/ _interopDefaultCompat(fs);
+var g__default = /*#__PURE__*/ _interopDefaultCompat(g);
+var path__default = /*#__PURE__*/ _interopDefaultCompat(path);
+var yaml__default = /*#__PURE__*/ _interopDefaultCompat(yaml);
+var limiterFactory__default =
+  /*#__PURE__*/ _interopDefaultCompat(limiterFactory);
+var stableStringify__default =
+  /*#__PURE__*/ _interopDefaultCompat(stableStringify);
+var uniq__default = /*#__PURE__*/ _interopDefaultCompat(uniq);
+var splitToChunks__default = /*#__PURE__*/ _interopDefaultCompat(splitToChunks);
+var yn__default = /*#__PURE__*/ _interopDefaultCompat(yn);
 
 const USER_PATTERN = /^@.*/;
 const GROUP_PATTERN = /^@.*\/.*/;
@@ -95,7 +107,7 @@ const scmCodeOwnersPaths = {
   // https://docs.gitlab.com/ee/user/project/code_owners.html#how-to-set-up-code-owners
   gitlab: [CODEOWNERS, `.gitlab/${CODEOWNERS}`, `docs/${CODEOWNERS}`],
   // https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners#codeowners-file-location
-  github: [CODEOWNERS, `.github/${CODEOWNERS}`, `docs/${CODEOWNERS}`]
+  github: [CODEOWNERS, `.github/${CODEOWNERS}`, `docs/${CODEOWNERS}`],
 };
 
 async function readCodeOwners(reader, sourceUrl, codeownersPaths) {
@@ -118,11 +130,19 @@ async function readCodeOwners(reader, sourceUrl, codeownersPaths) {
 }
 async function findCodeOwnerByTarget(reader, targetUrl, scmIntegration) {
   var _a;
-  const codeownersPaths = scmCodeOwnersPaths[(_a = scmIntegration == null ? void 0 : scmIntegration.type) != null ? _a : ""];
-  const sourceUrl = scmIntegration == null ? void 0 : scmIntegration.resolveUrl({
-    url: "/",
-    base: targetUrl
-  });
+  const codeownersPaths =
+    scmCodeOwnersPaths[
+      (_a = scmIntegration == null ? void 0 : scmIntegration.type) != null
+        ? _a
+        : ""
+    ];
+  const sourceUrl =
+    scmIntegration == null
+      ? void 0
+      : scmIntegration.resolveUrl({
+          url: "/",
+          base: targetUrl,
+        });
   if (!sourceUrl || !codeownersPaths) {
     return void 0;
   }
@@ -135,7 +155,15 @@ async function findCodeOwnerByTarget(reader, targetUrl, scmIntegration) {
 }
 
 var __defProp$c = Object.defineProperty;
-var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$c = (obj, key, value) =>
+  key in obj
+    ? __defProp$c(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$c = (obj, key, value) => {
   __defNormalProp$c(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
@@ -155,14 +183,19 @@ class CodeOwnersProcessor {
     const integrations = integration.ScmIntegrations.fromConfig(config);
     return new CodeOwnersProcessor({
       ...options,
-      integrations
+      integrations,
     });
   }
   getProcessorName() {
     return "CodeOwnersProcessor";
   }
   async preProcessEntity(entity, location) {
-    if (!entity || !ALLOWED_KINDS.includes(entity.kind) || !ALLOWED_LOCATION_TYPES.includes(location.type) || entity.spec && entity.spec.owner) {
+    if (
+      !entity ||
+      !ALLOWED_KINDS.includes(entity.kind) ||
+      !ALLOWED_LOCATION_TYPES.includes(location.type) ||
+      (entity.spec && entity.spec.owner)
+    ) {
       return entity;
     }
     const scmIntegration = this.integrations.byUrl(location.target);
@@ -182,7 +215,7 @@ class CodeOwnersProcessor {
     }
     return {
       ...entity,
-      spec: { ...entity.spec, owner }
+      spec: { ...entity.spec, owner },
     };
   }
 }
@@ -202,15 +235,21 @@ class AnnotateLocationEntityProcessor {
     if (location.type === "url") {
       const scmIntegration = integrations.byUrl(location.target);
       viewUrl = location.target;
-      editUrl = scmIntegration == null ? void 0 : scmIntegration.resolveEditUrl(location.target);
-      const sourceUrl = scmIntegration == null ? void 0 : scmIntegration.resolveUrl({
-        url: "./",
-        base: location.target
-      });
+      editUrl =
+        scmIntegration == null
+          ? void 0
+          : scmIntegration.resolveEditUrl(location.target);
+      const sourceUrl =
+        scmIntegration == null
+          ? void 0
+          : scmIntegration.resolveUrl({
+              url: "./",
+              base: location.target,
+            });
       if (sourceUrl) {
         sourceLocation = catalogModel.stringifyLocationRef({
           type: "url",
-          target: sourceUrl
+          target: sourceUrl,
         });
       }
     }
@@ -219,15 +258,17 @@ class AnnotateLocationEntityProcessor {
         metadata: {
           annotations: lodash.pickBy(
             {
-              [catalogModel.ANNOTATION_LOCATION]: catalogModel.stringifyLocationRef(location),
-              [catalogModel.ANNOTATION_ORIGIN_LOCATION]: catalogModel.stringifyLocationRef(originLocation),
+              [catalogModel.ANNOTATION_LOCATION]:
+                catalogModel.stringifyLocationRef(location),
+              [catalogModel.ANNOTATION_ORIGIN_LOCATION]:
+                catalogModel.stringifyLocationRef(originLocation),
               [catalogModel.ANNOTATION_VIEW_URL]: viewUrl,
               [catalogModel.ANNOTATION_EDIT_URL]: editUrl,
-              [catalogModel.ANNOTATION_SOURCE_LOCATION]: sourceLocation
+              [catalogModel.ANNOTATION_SOURCE_LOCATION]: sourceLocation,
             },
             lodash.identity
-          )
-        }
+          ),
+        },
       },
       entity
     );
@@ -235,9 +276,17 @@ class AnnotateLocationEntityProcessor {
 }
 
 var __defProp$b = Object.defineProperty;
-var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$b = (obj, key, value) =>
+  key in obj
+    ? __defProp$b(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$b = (obj, key, value) => {
-  __defNormalProp$b(obj, key + "" , value);
+  __defNormalProp$b(obj, key + "", value);
   return value;
 };
 class BuiltinKindsEntityProcessor {
@@ -250,7 +299,7 @@ class BuiltinKindsEntityProcessor {
       catalogModel.locationEntityV1alpha1Validator,
       catalogModel.userEntityV1alpha1Validator,
       catalogModel.systemEntityV1alpha1Validator,
-      catalogModel.domainEntityV1alpha1Validator
+      catalogModel.domainEntityV1alpha1Validator,
     ]);
   }
   getProcessorName() {
@@ -280,8 +329,8 @@ class BuiltinKindsEntityProcessor {
             target: {
               kind: targetRef.kind,
               namespace: targetRef.namespace,
-              name: targetRef.name
-            }
+              name: targetRef.name,
+            },
           })
         );
         emit(
@@ -289,10 +338,10 @@ class BuiltinKindsEntityProcessor {
             source: {
               kind: targetRef.kind,
               namespace: targetRef.namespace,
-              name: targetRef.name
+              name: targetRef.name,
             },
             type: incomingRelation,
-            target: selfRef
+            target: selfRef,
           })
         );
       }
@@ -462,8 +511,8 @@ class FileReaderProcessor {
             data,
             location: {
               type: LOCATION_TYPE,
-              target: normalizedFilePath
-            }
+              target: normalizedFilePath,
+            },
           })) {
             emit(parseResult);
             emit(
@@ -475,7 +524,9 @@ class FileReaderProcessor {
         }
       } else if (!optional) {
         const message = `${location.type} ${location.target} does not exist`;
-        emit(pluginCatalogNode.processingResult.notFoundError(location, message));
+        emit(
+          pluginCatalogNode.processingResult.notFoundError(location, message)
+        );
       }
     } catch (e) {
       const message = `${location.type} ${location.target} could not be read, ${e}`;
@@ -499,16 +550,18 @@ class PlaceholderProcessor {
       }
       if (Array.isArray(data)) {
         const items = await Promise.all(data.map((item) => process(item)));
-        return items.every(([, changed]) => !changed) ? [data, false] : [items.map(([item]) => item), true];
+        return items.every(([, changed]) => !changed)
+          ? [data, false]
+          : [items.map(([item]) => item), true];
       }
       const keys = Object.keys(data);
       if (!keys.some((k) => k.startsWith("$"))) {
         const entries = await Promise.all(
-          Object.entries(data).map(
-            ([k, v]) => process(v).then((vp) => [k, vp])
-          )
+          Object.entries(data).map(([k, v]) => process(v).then((vp) => [k, vp]))
         );
-        return entries.every(([, [, changed]]) => !changed) ? [data, false] : [Object.fromEntries(entries.map(([k, [v]]) => [k, v])), true];
+        return entries.every(([, [, changed]]) => !changed)
+          ? [data, false]
+          : [Object.fromEntries(entries.map(([k, [v]]) => [k, v])), true];
       } else if (keys.length !== 1) {
         return [data, false];
       }
@@ -523,10 +576,11 @@ class PlaceholderProcessor {
         const buffer = await response.buffer();
         return buffer;
       };
-      const resolveUrl = (url, base) => this.options.integrations.resolveUrl({
-        url,
-        base
-      });
+      const resolveUrl = (url, base) =>
+        this.options.integrations.resolveUrl({
+          url,
+          base,
+        });
       return [
         await resolver({
           key: resolverKey,
@@ -534,9 +588,9 @@ class PlaceholderProcessor {
           baseUrl: location.target,
           read,
           resolveUrl,
-          emit
+          emit,
         }),
-        true
+        true,
       ];
     };
     const [result] = await process(entity);
@@ -549,7 +603,9 @@ async function yamlPlaceholderResolver(params) {
   params.emit(pluginCatalogNode.processingResult.refresh(`url:${url}`));
   let documents;
   try {
-    documents = yaml__default.default.parseAllDocuments(content).filter((d) => d);
+    documents = yaml__default.default
+      .parseAllDocuments(content)
+      .filter((d) => d);
   } catch (e) {
     throw new Error(
       `Placeholder $${params.key} failed to parse YAML data at ${params.value}, ${e}`
@@ -595,12 +651,7 @@ async function readTextLocation(params) {
     );
   }
 }
-function relativeUrl({
-  key,
-  value,
-  baseUrl,
-  resolveUrl
-}) {
+function relativeUrl({ key, value, baseUrl, resolveUrl }) {
   if (typeof value !== "string") {
     throw new Error(
       `Placeholder $${key} expected a string value parameter, in the form of an absolute URL or a relative path`
@@ -637,7 +688,7 @@ class UrlReaderProcessor {
       for (const item of response) {
         for await (const parseResult of parser({
           data: item.data,
-          location: { type: location.type, target: item.url }
+          location: { type: location.type, target: item.url },
         })) {
           parseResults.push(parseResult);
           emit(parseResult);
@@ -647,10 +698,14 @@ class UrlReaderProcessor {
       if (newEtag && isOnlyEntities) {
         await cache.set(CACHE_KEY, {
           etag: newEtag,
-          value: parseResults
+          value: parseResults,
         });
       }
-      emit(pluginCatalogNode.processingResult.refresh(`${location.type}:${location.target}`));
+      emit(
+        pluginCatalogNode.processingResult.refresh(
+          `${location.type}:${location.target}`
+        )
+      );
     } catch (error) {
       errors.assertError(error);
       const message = `Unable to read ${location.type}, ${error}`.substring(
@@ -661,13 +716,21 @@ class UrlReaderProcessor {
         for (const parseResult of cacheItem.value) {
           emit(parseResult);
         }
-        emit(pluginCatalogNode.processingResult.refresh(`${location.type}:${location.target}`));
+        emit(
+          pluginCatalogNode.processingResult.refresh(
+            `${location.type}:${location.target}`
+          )
+        );
       } else if (error.name === "NotFoundError") {
         if (!optional) {
-          emit(pluginCatalogNode.processingResult.notFoundError(location, message));
+          emit(
+            pluginCatalogNode.processingResult.notFoundError(location, message)
+          );
         }
       } else {
-        emit(pluginCatalogNode.processingResult.generalError(location, message));
+        emit(
+          pluginCatalogNode.processingResult.generalError(location, message)
+        );
       }
     }
     return true;
@@ -679,14 +742,14 @@ class UrlReaderProcessor {
       const response = await this.options.reader.search(location, { etag });
       const output = response.files.map(async (file) => ({
         url: file.url,
-        data: await limiter(file.content)
+        data: await limiter(file.content),
       }));
       return { response: await Promise.all(output), etag: response.etag };
     }
     const data = await this.options.reader.readUrl(location, { etag });
     return {
       response: [{ url: location, data: await data.buffer() }],
-      etag: data.etag
+      etag: data.etag,
     };
   }
 }
@@ -695,7 +758,9 @@ function* parseEntityYaml(data, location) {
   var _a;
   let documents;
   try {
-    documents = yaml__default.default.parseAllDocuments(data.toString("utf8")).filter((d) => d);
+    documents = yaml__default.default
+      .parseAllDocuments(data.toString("utf8"))
+      .filter((d) => d);
   } catch (e) {
     const loc = catalogModel.stringifyLocationRef(location);
     const message = `Failed to parse YAML at ${loc}, ${e}`;
@@ -711,14 +776,21 @@ function* parseEntityYaml(data, location) {
       const json = document.toJSON();
       if (lodash__default.default.isPlainObject(json)) {
         yield pluginCatalogNode.processingResult.entity(location, json);
-      } else if (json === null) ; else {
+      } else if (json === null);
+      else {
         const message = `Expected object at root, got ${typeof json}`;
-        yield pluginCatalogNode.processingResult.generalError(location, message);
+        yield pluginCatalogNode.processingResult.generalError(
+          location,
+          message
+        );
       }
     }
   }
 }
-const defaultEntityDataParser = async function* defaultEntityDataParser2({ data, location }) {
+const defaultEntityDataParser = async function* defaultEntityDataParser2({
+  data,
+  location,
+}) {
   for (const e of parseEntityYaml(data, location)) {
     yield e;
   }
@@ -736,7 +808,10 @@ function isLocationEntity(entity) {
 }
 function getEntityLocationRef(entity) {
   var _a;
-  const ref = (_a = entity.metadata.annotations) == null ? void 0 : _a[catalogModel.ANNOTATION_LOCATION];
+  const ref =
+    (_a = entity.metadata.annotations) == null
+      ? void 0
+      : _a[catalogModel.ANNOTATION_LOCATION];
   if (!ref) {
     const entityRef = catalogModel.stringifyEntityRef(entity);
     throw new errors.InputError(
@@ -747,7 +822,10 @@ function getEntityLocationRef(entity) {
 }
 function getEntityOriginLocationRef(entity) {
   var _a;
-  const ref = (_a = entity.metadata.annotations) == null ? void 0 : _a[catalogModel.ANNOTATION_ORIGIN_LOCATION];
+  const ref =
+    (_a = entity.metadata.annotations) == null
+      ? void 0
+      : _a[catalogModel.ANNOTATION_ORIGIN_LOCATION];
   if (!ref) {
     const entityRef = catalogModel.stringifyEntityRef(entity);
     throw new errors.InputError(
@@ -763,7 +841,10 @@ function toAbsoluteUrl(integrations, base, type, target) {
   try {
     if (type === "file") {
       if (target.startsWith(".")) {
-        return path__default.default.join(path__default.default.dirname(base.target), target);
+        return path__default.default.join(
+          path__default.default.dirname(base.target),
+          target
+        );
       }
       return target;
     } else if (type === "url") {
@@ -781,7 +862,10 @@ const validateEntity = catalogModel.entitySchemaValidator();
 const validateEntityEnvelope = catalogModel.entityEnvelopeSchemaValidator();
 
 function locationSpecToMetadataName(location) {
-  const hash = crypto.createHash("sha1").update(`${location.type}:${location.target}`).digest("hex");
+  const hash = crypto
+    .createHash("sha1")
+    .update(`${location.type}:${location.target}`)
+    .digest("hex");
   return `generated-${hash}`;
 }
 function locationSpecToLocationEntity(opts) {
@@ -791,7 +875,10 @@ function locationSpecToLocationEntity(opts) {
   let ownLocation;
   let originLocation;
   if (parentEntity) {
-    const maybeOwnLocation = (_a = parentEntity.metadata.annotations) == null ? void 0 : _a[catalogModel.ANNOTATION_LOCATION];
+    const maybeOwnLocation =
+      (_a = parentEntity.metadata.annotations) == null
+        ? void 0
+        : _a[catalogModel.ANNOTATION_LOCATION];
     if (!maybeOwnLocation) {
       throw new Error(
         `Parent entity '${catalogModel.stringifyEntityRef(
@@ -802,7 +889,10 @@ function locationSpecToLocationEntity(opts) {
       );
     }
     ownLocation = maybeOwnLocation;
-    const maybeOriginLocation = (_b = parentEntity.metadata.annotations) == null ? void 0 : _b[catalogModel.ANNOTATION_ORIGIN_LOCATION];
+    const maybeOriginLocation =
+      (_b = parentEntity.metadata.annotations) == null
+        ? void 0
+        : _b[catalogModel.ANNOTATION_ORIGIN_LOCATION];
     if (!maybeOriginLocation) {
       throw new Error(
         `Parent entity '${catalogModel.stringifyEntityRef(
@@ -824,14 +914,14 @@ function locationSpecToLocationEntity(opts) {
       name: locationSpecToMetadataName(location),
       annotations: {
         [catalogModel.ANNOTATION_LOCATION]: ownLocation,
-        [catalogModel.ANNOTATION_ORIGIN_LOCATION]: originLocation
-      }
+        [catalogModel.ANNOTATION_ORIGIN_LOCATION]: originLocation,
+      },
     },
     spec: {
       type: location.type,
       target: location.target,
-      presence: location.presence
-    }
+      presence: location.presence,
+    },
   };
   return result;
 }
@@ -847,7 +937,7 @@ class ConfigLocationEntityProvider {
     const entities = this.getEntitiesFromConfig();
     await connection.applyMutation({
       type: "full",
-      entities
+      entities,
     });
     if (this.config.subscribe) {
       let currentKey = JSON.stringify(entities);
@@ -858,7 +948,7 @@ class ConfigLocationEntityProvider {
           currentKey = newKey;
           connection.applyMutation({
             type: "full",
-            entities: newEntities
+            entities: newEntities,
           });
         }
       });
@@ -866,15 +956,19 @@ class ConfigLocationEntityProvider {
   }
   getEntitiesFromConfig() {
     var _a;
-    const locationConfigs = (_a = this.config.getOptionalConfigArray("catalog.locations")) != null ? _a : [];
+    const locationConfigs =
+      (_a = this.config.getOptionalConfigArray("catalog.locations")) != null
+        ? _a
+        : [];
     return locationConfigs.map((location) => {
       const type = location.getString("type");
       const target = location.getString("target");
       const entity = locationSpecToLocationEntity({
         location: {
           type,
-          target: type === "file" ? path__default.default.resolve(target) : target
-        }
+          target:
+            type === "file" ? path__default.default.resolve(target) : target,
+        },
       });
       const locationKey = getEntityLocationRef(entity);
       return { entity, locationKey };
@@ -883,9 +977,17 @@ class ConfigLocationEntityProvider {
 }
 
 var __defProp$a = Object.defineProperty;
-var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$a = (obj, key, value) =>
+  key in obj
+    ? __defProp$a(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$a = (obj, key, value) => {
-  __defNormalProp$a(obj, key + "" , value);
+  __defNormalProp$a(obj, key + "", value);
   return value;
 };
 class DefaultLocationStore {
@@ -910,7 +1012,7 @@ class DefaultLocationStore {
       const inner = {
         id: uuid.v4(),
         type: input.type,
-        target: input.target
+        target: input.target,
       };
       await tx("locations").insert(inner);
       return inner;
@@ -919,7 +1021,7 @@ class DefaultLocationStore {
     await this.connection.applyMutation({
       type: "delta",
       added: [{ entity, locationKey: getEntityLocationRef(entity) }],
-      removed: []
+      removed: [],
     });
     return location;
   }
@@ -949,26 +1051,37 @@ class DefaultLocationStore {
     await this.connection.applyMutation({
       type: "delta",
       added: [],
-      removed: [{ entity, locationKey: getEntityLocationRef(entity) }]
+      removed: [{ entity, locationKey: getEntityLocationRef(entity) }],
     });
   }
   async getLocationByEntity(entityRef) {
     const entityRefString = catalogModel.stringifyEntityRef(entityRef);
-    const [entity] = await this.db("refresh_state").where({ entity_ref: entityRefString }).select("entity_id").limit(1);
+    const [entity] = await this.db("refresh_state")
+      .where({ entity_ref: entityRefString })
+      .select("entity_id")
+      .limit(1);
     if (!entity) {
-      throw new errors.NotFoundError(`found no entity for ref ${entityRefString}`);
+      throw new errors.NotFoundError(
+        `found no entity for ref ${entityRefString}`
+      );
     }
-    const [locationKeyValue] = await this.db("search").where({
-      entity_id: entity.entity_id,
-      key: `metadata.annotations.${catalogModel.ANNOTATION_ORIGIN_LOCATION}`
-    }).select("value").limit(1);
+    const [locationKeyValue] = await this.db("search")
+      .where({
+        entity_id: entity.entity_id,
+        key: `metadata.annotations.${catalogModel.ANNOTATION_ORIGIN_LOCATION}`,
+      })
+      .select("value")
+      .limit(1);
     if (!locationKeyValue) {
       throw new errors.NotFoundError(
         `found no origin annotation for ref ${entityRefString}`
       );
     }
     const { type, target } = catalogModel.parseLocationRef(entityRefString);
-    const [location] = await this.db("locations").where({ type, target }).select().limit(1);
+    const [location] = await this.db("locations")
+      .where({ type, target })
+      .select()
+      .limit(1);
     if (!location) {
       throw new errors.NotFoundError(
         `Found no location with type ${type} and target ${target}`
@@ -991,21 +1104,31 @@ class DefaultLocationStore {
     });
     await this.connection.applyMutation({
       type: "full",
-      entities
+      entities,
     });
   }
   async locations(dbOrTx = this.db) {
     const locations = await dbOrTx("locations").select();
-    return locations.filter(({ type }) => type !== "bootstrap").map((item) => ({
-      id: item.id,
-      target: item.target,
-      type: item.type
-    }));
+    return locations
+      .filter(({ type }) => type !== "bootstrap")
+      .map((item) => ({
+        id: item.id,
+        target: item.target,
+        type: item.type,
+      }));
   }
 }
 
 var __defProp$9 = Object.defineProperty;
-var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$9 = (obj, key, value) =>
+  key in obj
+    ? __defProp$9(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$9 = (obj, key, value) => {
   __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
@@ -1021,7 +1144,9 @@ class RepoLocationAnalyzer {
   }
   async analyzeLocation(request) {
     const integration = this.scmIntegrations.byUrl(request.location.target);
-    const { owner, name } = parseGitUrl__default.default(request.location.target);
+    const { owner, name } = parseGitUrl__default.default(
+      request.location.target
+    );
     let annotationPrefix;
     switch (integration == null ? void 0 : integration.type) {
       case "azure":
@@ -1037,12 +1162,12 @@ class RepoLocationAnalyzer {
         annotationPrefix = "gitlab.com";
         break;
     }
-    const analyzer = this.analyzers.find(
-      (a) => a.supports(request.location.target)
+    const analyzer = this.analyzers.find((a) =>
+      a.supports(request.location.target)
     );
     if (analyzer) {
       const analyzerResult = await analyzer.analyze({
-        url: request.location.target
+        url: request.location.target,
       });
       if (analyzerResult.existing.length > 0) {
         this.logger.debug(
@@ -1050,7 +1175,7 @@ class RepoLocationAnalyzer {
         );
         return {
           existingEntityFiles: analyzerResult.existing,
-          generateEntities: []
+          generateEntities: [],
         };
       }
     }
@@ -1058,19 +1183,19 @@ class RepoLocationAnalyzer {
       apiVersion: "backstage.io/v1alpha1",
       kind: "Component",
       metadata: {
-        name
+        name,
       },
-      spec: { type: "other", lifecycle: "unknown" }
+      spec: { type: "other", lifecycle: "unknown" },
     };
     if (annotationPrefix) {
       entity.metadata.annotations = {
-        [`${annotationPrefix}/project-slug`]: `${owner}/${name}`
+        [`${annotationPrefix}/project-slug`]: `${owner}/${name}`,
       };
     }
     this.logger.debug(`entity created for ${request.location.target}`);
     return {
       existingEntityFiles: [],
-      generateEntities: [{ entity, fields: [] }]
+      generateEntities: [{ entity, fields: [] }],
     };
   }
 }
@@ -1080,13 +1205,18 @@ function timestampToDateTime(input) {
     if (typeof input === "object") {
       return luxon.DateTime.fromJSDate(input).toUTC();
     }
-    const result = input.includes(" ") ? luxon.DateTime.fromSQL(input, { zone: "utc" }) : luxon.DateTime.fromISO(input, { zone: "utc" });
+    const result = input.includes(" ")
+      ? luxon.DateTime.fromSQL(input, { zone: "utc" })
+      : luxon.DateTime.fromISO(input, { zone: "utc" });
     if (!result.isValid) {
       throw new TypeError("Not valid");
     }
     return result;
   } catch (e) {
-    throw new errors.InputError(`Failed to parse database timestamp ${input}`, e);
+    throw new errors.InputError(
+      `Failed to parse database timestamp ${input}`,
+      e
+    );
   }
 }
 function rethrowError(e) {
@@ -1131,10 +1261,13 @@ function initDatabaseMetrics(knex) {
       help: "Total amount of entities in the catalog. DEPRECATED: Please use opentelemetry metrics instead.",
       labelNames: ["kind"],
       async collect() {
-        const result = await knex("refresh_state").select(
-          "entity_ref"
-        );
-        const results = result.map((row) => row.entity_ref.split(":")[0]).reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), /* @__PURE__ */ new Map());
+        const result = await knex("refresh_state").select("entity_ref");
+        const results = result
+          .map((row) => row.entity_ref.split(":")[0])
+          .reduce(
+            (acc, e) => acc.set(e, (acc.get(e) || 0) + 1),
+            /* @__PURE__ */ new Map()
+          );
         results.forEach((value, key) => {
           seenProm.add(key);
           this.set({ kind: key }, value);
@@ -1145,68 +1278,80 @@ function initDatabaseMetrics(knex) {
             seenProm.delete(key);
           }
         });
-      }
+      },
     }),
     registered_locations_prom: createGaugeMetric({
       name: "catalog_registered_locations_count",
       help: "Total amount of registered locations in the catalog. DEPRECATED: Please use opentelemetry metrics instead.",
       async collect() {
         const total = await knex("locations").count({
-          count: "*"
+          count: "*",
         });
         this.set(Number(total[0].count));
-      }
+      },
     }),
     relations_prom: createGaugeMetric({
       name: "catalog_relations_count",
       help: "Total amount of relations between entities. DEPRECATED: Please use opentelemetry metrics instead.",
       async collect() {
         const total = await knex("relations").count({
-          count: "*"
+          count: "*",
         });
         this.set(Number(total[0].count));
-      }
-    }),
-    entities_count: meter.createObservableGauge("catalog_entities_count", {
-      description: "Total amount of entities in the catalog"
-    }).addCallback(async (gauge) => {
-      const result = await knex("refresh_state").select(
-        "entity_ref"
-      );
-      const results = result.map((row) => catalogModel.parseEntityRef(row.entity_ref).kind).reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), /* @__PURE__ */ new Map());
-      results.forEach((value, key) => {
-        seen.add(key);
-        gauge.observe(value, { kind: key });
-      });
-      seen.forEach((key) => {
-        if (!results.has(key)) {
-          gauge.observe(0, { kind: key });
-          seen.delete(key);
-        }
-      });
-    }),
-    registered_locations: meter.createObservableGauge("catalog_registered_locations_count", {
-      description: "Total amount of registered locations in the catalog"
-    }).addCallback(async (gauge) => {
-      const total = await knex("locations").count({
-        count: "*"
-      });
-      gauge.observe(Number(total[0].count));
+      },
     }),
-    relations: meter.createObservableGauge("catalog_relations_count", {
-      description: "Total amount of relations between entities"
-    }).addCallback(async (gauge) => {
-      const total = await knex("relations").count({
-        count: "*"
-      });
-      gauge.observe(Number(total[0].count));
-    })
+    entities_count: meter
+      .createObservableGauge("catalog_entities_count", {
+        description: "Total amount of entities in the catalog",
+      })
+      .addCallback(async (gauge) => {
+        const result = await knex("refresh_state").select("entity_ref");
+        const results = result
+          .map((row) => catalogModel.parseEntityRef(row.entity_ref).kind)
+          .reduce(
+            (acc, e) => acc.set(e, (acc.get(e) || 0) + 1),
+            /* @__PURE__ */ new Map()
+          );
+        results.forEach((value, key) => {
+          seen.add(key);
+          gauge.observe(value, { kind: key });
+        });
+        seen.forEach((key) => {
+          if (!results.has(key)) {
+            gauge.observe(0, { kind: key });
+            seen.delete(key);
+          }
+        });
+      }),
+    registered_locations: meter
+      .createObservableGauge("catalog_registered_locations_count", {
+        description: "Total amount of registered locations in the catalog",
+      })
+      .addCallback(async (gauge) => {
+        const total = await knex("locations").count({
+          count: "*",
+        });
+        gauge.observe(Number(total[0].count));
+      }),
+    relations: meter
+      .createObservableGauge("catalog_relations_count", {
+        description: "Total amount of relations between entities",
+      })
+      .addCallback(async (gauge) => {
+        const total = await knex("relations").count({
+          count: "*",
+        });
+        gauge.observe(Number(total[0].count));
+      }),
   };
 }
 
 async function checkLocationKeyConflict(options) {
   const { tx, entityRef, locationKey } = options;
-  const row = await tx("refresh_state").select("location_key").where("entity_ref", entityRef).first();
+  const row = await tx("refresh_state")
+    .select("location_key")
+    .where("entity_ref", entityRef)
+    .first();
   const conflictingKey = row == null ? void 0 : row.location_key;
   if (!conflictingKey) {
     return void 0;
@@ -1230,7 +1375,7 @@ async function insertUnprocessedEntity(options) {
       errors: "",
       location_key: locationKey,
       next_update_at: tx.fn.now(),
-      last_discovery_at: tx.fn.now()
+      last_discovery_at: tx.fn.now(),
     });
     if (tx.client.config.client.includes("pg")) {
       query = query.onConflict("entity_ref").ignore();
@@ -1251,26 +1396,34 @@ async function updateUnprocessedEntity(options) {
   const { tx, entity, hash, locationKey } = options;
   const entityRef = catalogModel.stringifyEntityRef(entity);
   const serializedEntity = JSON.stringify(entity);
-  const refreshResult = await tx("refresh_state").update({
-    unprocessed_entity: serializedEntity,
-    unprocessed_hash: hash,
-    location_key: locationKey,
-    last_discovery_at: tx.fn.now(),
-    // We only get to this point if a processed entity actually had any changes, or
-    // if an entity provider requested this mutation, meaning that we can safely
-    // bump the deferred entities to the front of the queue for immediate processing.
-    next_update_at: tx.fn.now()
-  }).where("entity_ref", entityRef).andWhere((inner) => {
-    if (!locationKey) {
-      return inner.whereNull("location_key");
-    }
-    return inner.where("location_key", locationKey).orWhereNull("location_key");
-  });
+  const refreshResult = await tx("refresh_state")
+    .update({
+      unprocessed_entity: serializedEntity,
+      unprocessed_hash: hash,
+      location_key: locationKey,
+      last_discovery_at: tx.fn.now(),
+      // We only get to this point if a processed entity actually had any changes, or
+      // if an entity provider requested this mutation, meaning that we can safely
+      // bump the deferred entities to the front of the queue for immediate processing.
+      next_update_at: tx.fn.now(),
+    })
+    .where("entity_ref", entityRef)
+    .andWhere((inner) => {
+      if (!locationKey) {
+        return inner.whereNull("location_key");
+      }
+      return inner
+        .where("location_key", locationKey)
+        .orWhereNull("location_key");
+    });
   return refreshResult === 1;
 }
 
 function generateStableHash$1(entity) {
-  return crypto.createHash("sha1").update(stableStringify__default.default({ ...entity })).digest("hex");
+  return crypto
+    .createHash("sha1")
+    .update(stableStringify__default.default({ ...entity }))
+    .digest("hex");
 }
 
 const CATALOG_CONFLICTS_TOPIC = "experimental.catalog.conflict";
@@ -1292,20 +1445,25 @@ class DefaultProcessingDatabase {
       relations,
       deferredEntities,
       refreshKeys,
-      locationKey
+      locationKey,
     } = options;
     const configClient = tx.client.config.client;
-    const refreshResult = await tx("refresh_state").update({
-      processed_entity: JSON.stringify(processedEntity),
-      result_hash: resultHash,
-      errors: errors$1,
-      location_key: locationKey
-    }).where("entity_id", id).andWhere((inner) => {
-      if (!locationKey) {
-        return inner.whereNull("location_key");
-      }
-      return inner.where("location_key", locationKey).orWhereNull("location_key");
-    });
+    const refreshResult = await tx("refresh_state")
+      .update({
+        processed_entity: JSON.stringify(processedEntity),
+        result_hash: resultHash,
+        errors: errors$1,
+        location_key: locationKey,
+      })
+      .where("entity_id", id)
+      .andWhere((inner) => {
+        if (!locationKey) {
+          return inner.whereNull("location_key");
+        }
+        return inner
+          .where("location_key", locationKey)
+          .orWhereNull("location_key");
+      });
     if (refreshResult === 0) {
       throw new errors.ConflictError(
         `Conflicting write of processing result for ${id} with location key '${locationKey}'`
@@ -1314,23 +1472,26 @@ class DefaultProcessingDatabase {
     const sourceEntityRef = catalogModel.stringifyEntityRef(processedEntity);
     await this.addUnprocessedEntities(tx, {
       entities: deferredEntities,
-      sourceEntityRef
+      sourceEntityRef,
     });
     let previousRelationRows;
     if (configClient.includes("sqlite3") || configClient.includes("mysql")) {
-      previousRelationRows = await tx("relations").select("*").where({ originating_entity_id: id });
+      previousRelationRows = await tx("relations")
+        .select("*")
+        .where({ originating_entity_id: id });
       await tx("relations").where({ originating_entity_id: id }).delete();
     } else {
-      previousRelationRows = await tx("relations").where({ originating_entity_id: id }).delete().returning("*");
-    }
-    const relationRows = relations.map(
-      ({ source, target, type }) => ({
-        originating_entity_id: id,
-        source_entity_ref: catalogModel.stringifyEntityRef(source),
-        target_entity_ref: catalogModel.stringifyEntityRef(target),
-        type
-      })
-    );
+      previousRelationRows = await tx("relations")
+        .where({ originating_entity_id: id })
+        .delete()
+        .returning("*");
+    }
+    const relationRows = relations.map(({ source, target, type }) => ({
+      originating_entity_id: id,
+      source_entity_ref: catalogModel.stringifyEntityRef(source),
+      target_entity_ref: catalogModel.stringifyEntityRef(target),
+      type,
+    }));
     await tx.batchInsert(
       "relations",
       this.deduplicateRelations(relationRows),
@@ -1341,28 +1502,32 @@ class DefaultProcessingDatabase {
       "refresh_keys",
       refreshKeys.map((k) => ({
         entity_id: id,
-        key: k.key
+        key: k.key,
       })),
       BATCH_SIZE$2
     );
     return {
       previous: {
-        relations: previousRelationRows
-      }
+        relations: previousRelationRows,
+      },
     };
   }
   async updateProcessedEntityErrors(txOpaque, options) {
     const tx = txOpaque;
     const { id, errors, resultHash } = options;
-    await tx("refresh_state").update({
-      errors,
-      result_hash: resultHash
-    }).where("entity_id", id);
+    await tx("refresh_state")
+      .update({
+        errors,
+        result_hash: resultHash,
+      })
+      .where("entity_id", id);
   }
   async updateEntityCache(txOpaque, options) {
     const tx = txOpaque;
     const { id, state } = options;
-    await tx("refresh_state").update({ cache: JSON.stringify(state != null ? state : {}) }).where("entity_id", id);
+    await tx("refresh_state")
+      .update({ cache: JSON.stringify(state != null ? state : {}) })
+      .where("entity_id", id);
   }
   async getProcessableEntities(txOpaque, request) {
     const tx = txOpaque;
@@ -1370,7 +1535,10 @@ class DefaultProcessingDatabase {
     if (["mysql", "mysql2", "pg"].includes(tx.client.config.client)) {
       itemsQuery = itemsQuery.forUpdate().skipLocked();
     }
-    const items = await itemsQuery.where("next_update_at", "<=", tx.fn.now()).limit(request.processBatchSize).orderBy("next_update_at", "asc");
+    const items = await itemsQuery
+      .where("next_update_at", "<=", tx.fn.now())
+      .limit(request.processBatchSize)
+      .orderBy("next_update_at", "asc");
     const interval = this.options.refreshInterval();
     const nextUpdateAt = (refreshInterval) => {
       if (tx.client.config.client.includes("sqlite3")) {
@@ -1381,34 +1549,36 @@ class DefaultProcessingDatabase {
       }
       return tx.raw(`now() + interval '${refreshInterval} seconds'`);
     };
-    await tx("refresh_state").whereIn(
-      "entity_ref",
-      items.map((i) => i.entity_ref)
-    ).update({
-      next_update_at: nextUpdateAt(interval)
-    });
-    return {
-      items: items.map(
-        (i) => ({
-          id: i.entity_id,
-          entityRef: i.entity_ref,
-          unprocessedEntity: JSON.parse(i.unprocessed_entity),
-          processedEntity: i.processed_entity ? JSON.parse(i.processed_entity) : void 0,
-          resultHash: i.result_hash || "",
-          nextUpdateAt: timestampToDateTime(i.next_update_at),
-          lastDiscoveryAt: timestampToDateTime(i.last_discovery_at),
-          state: i.cache ? JSON.parse(i.cache) : void 0,
-          errors: i.errors,
-          locationKey: i.location_key
-        })
+    await tx("refresh_state")
+      .whereIn(
+        "entity_ref",
+        items.map((i) => i.entity_ref)
       )
+      .update({
+        next_update_at: nextUpdateAt(interval),
+      });
+    return {
+      items: items.map((i) => ({
+        id: i.entity_id,
+        entityRef: i.entity_ref,
+        unprocessedEntity: JSON.parse(i.unprocessed_entity),
+        processedEntity: i.processed_entity
+          ? JSON.parse(i.processed_entity)
+          : void 0,
+        resultHash: i.result_hash || "",
+        nextUpdateAt: timestampToDateTime(i.next_update_at),
+        lastDiscoveryAt: timestampToDateTime(i.last_discovery_at),
+        state: i.cache ? JSON.parse(i.cache) : void 0,
+        errors: i.errors,
+        locationKey: i.location_key,
+      })),
     };
   }
   async listParents(txOpaque, options) {
     const tx = txOpaque;
-    const rows = await tx(
-      "refresh_state_references"
-    ).where({ target_entity_ref: options.entityRef }).select();
+    const rows = await tx("refresh_state_references")
+      .where({ target_entity_ref: options.entityRef })
+      .select();
     const entityRefs = rows.map((r) => r.source_entity_ref).filter(Boolean);
     return { entityRefs };
   }
@@ -1421,7 +1591,7 @@ class DefaultProcessingDatabase {
         },
         {
           // If we explicitly trigger a rollback, don't fail.
-          doNotRejectOnRollback: true
+          doNotRejectOnRollback: true,
         }
       );
       return result;
@@ -1451,7 +1621,7 @@ class DefaultProcessingDatabase {
         tx,
         entity,
         hash,
-        locationKey
+        locationKey,
       });
       if (updated) {
         stateReferences.push(entityRef);
@@ -1462,7 +1632,7 @@ class DefaultProcessingDatabase {
         entity,
         hash,
         locationKey,
-        logger: this.options.logger
+        logger: this.options.logger,
       });
       if (inserted) {
         stateReferences.push(entityRef);
@@ -1471,7 +1641,7 @@ class DefaultProcessingDatabase {
       const conflictingKey = await checkLocationKeyConflict({
         tx,
         entityRef,
-        locationKey
+        locationKey,
       });
       if (conflictingKey) {
         this.options.logger.warn(
@@ -1485,19 +1655,23 @@ class DefaultProcessingDatabase {
               entityRef,
               newLocationKey: locationKey,
               existingLocationKey: conflictingKey,
-              lastConflictAt: luxon.DateTime.now().toISO()
-            }
+              lastConflictAt: luxon.DateTime.now().toISO(),
+            },
           };
-          await ((_a = this.options.eventBroker) == null ? void 0 : _a.publish(eventParams));
+          await ((_a = this.options.eventBroker) == null
+            ? void 0
+            : _a.publish(eventParams));
         }
       }
     }
-    await tx("refresh_state_references").andWhere({ source_entity_ref: options.sourceEntityRef }).delete();
+    await tx("refresh_state_references")
+      .andWhere({ source_entity_ref: options.sourceEntityRef })
+      .delete();
     await tx.batchInsert(
       "refresh_state_references",
       stateReferences.map((entityRef) => ({
         source_entity_ref: options.sourceEntityRef,
-        target_entity_ref: entityRef
+        target_entity_ref: entityRef,
       })),
       BATCH_SIZE$2
     );
@@ -1510,7 +1684,7 @@ async function applyDatabaseMigrations(knex) {
     "migrations"
   );
   await knex.migrate.latest({
-    directory: migrationsDir
+    directory: migrationsDir,
   });
 }
 
@@ -1520,13 +1694,13 @@ function stitchingStrategyFromConfig(config) {
   );
   if (strategyMode === void 0 || strategyMode === "immediate") {
     return {
-      mode: "immediate"
+      mode: "immediate",
     };
   } else if (strategyMode === "deferred") {
     return {
       mode: "deferred",
       pollingInterval: { seconds: 1 },
-      stitchTimeout: { seconds: 60 }
+      stitchTimeout: { seconds: 60 },
     };
   }
   throw new Error(
@@ -1558,11 +1732,16 @@ function addEntityAttributes(span, entity) {
 const onException = (e, span) => {
   span.recordException(e);
   span.setStatus({
-    code: api.SpanStatusCode.ERROR
+    code: api.SpanStatusCode.ERROR,
   });
 };
 function isPromiseLike(obj) {
-  return !!obj && (typeof obj === "object" || typeof obj === "function") && "then" in obj && typeof obj.then === "function";
+  return (
+    !!obj &&
+    (typeof obj === "object" || typeof obj === "function") &&
+    "then" in obj &&
+    typeof obj.then === "function"
+  );
 }
 function handleFn(span, fn) {
   try {
@@ -1601,7 +1780,7 @@ function startTaskPipeline(options) {
     processTask,
     lowWatermark,
     highWatermark,
-    pollingIntervalMs = DEFAULT_POLLING_INTERVAL_MS
+    pollingIntervalMs = DEFAULT_POLLING_INTERVAL_MS,
   } = options;
   if (lowWatermark >= highWatermark) {
     throw new Error("lowWatermark must be lower than highWatermark");
@@ -1611,25 +1790,29 @@ function startTaskPipeline(options) {
   const abortSignal = abortController.signal;
   const barrier = createBarrier({
     waitTimeoutMillis: pollingIntervalMs,
-    signal: abortSignal
+    signal: abortSignal,
   });
   async function pipelineLoop() {
     while (!abortSignal.aborted) {
       if (state.inFlightCount <= lowWatermark) {
         await withActiveSpan(tracer$2, "TaskPipelineLoop", async (span) => {
           const loadCount = highWatermark - state.inFlightCount;
-          const loadedItems = await Promise.resolve().then(() => loadTasks(loadCount)).catch(() => {
-            return [];
-          });
+          const loadedItems = await Promise.resolve()
+            .then(() => loadTasks(loadCount))
+            .catch(() => {
+              return [];
+            });
           span.setAttribute("itemCount", loadedItems.length);
           if (loadedItems.length && !abortSignal.aborted) {
             state.inFlightCount += loadedItems.length;
             for (const item of loadedItems) {
-              Promise.resolve().then(() => processTask(item)).catch(() => {
-              }).finally(() => {
-                state.inFlightCount -= 1;
-                barrier.release();
-              });
+              Promise.resolve()
+                .then(() => processTask(item))
+                .catch(() => {})
+                .finally(() => {
+                  state.inFlightCount -= 1;
+                  barrier.release();
+                });
             }
           }
         });
@@ -1673,7 +1856,7 @@ function createBarrier(options) {
   return {
     wait,
     release,
-    destroy: () => signal.removeEventListener("abort", release)
+    destroy: () => signal.removeEventListener("abort", release),
   };
 }
 
@@ -1684,39 +1867,55 @@ async function markForStitching(options) {
   const mode = options.strategy.mode;
   if (mode === "immediate") {
     for (const chunk of entityRefs) {
-      await knex.table("final_entities").update({
-        hash: "force-stitching"
-      }).whereIn(
-        "entity_id",
-        knex("refresh_state").select("entity_id").whereIn("entity_ref", chunk)
-      );
-      await knex.table("refresh_state").update({
-        result_hash: "force-stitching",
-        next_update_at: knex.fn.now()
-      }).whereIn("entity_ref", chunk);
+      await knex
+        .table("final_entities")
+        .update({
+          hash: "force-stitching",
+        })
+        .whereIn(
+          "entity_id",
+          knex("refresh_state").select("entity_id").whereIn("entity_ref", chunk)
+        );
+      await knex
+        .table("refresh_state")
+        .update({
+          result_hash: "force-stitching",
+          next_update_at: knex.fn.now(),
+        })
+        .whereIn("entity_ref", chunk);
     }
     for (const chunk of entityIds) {
-      await knex.table("final_entities").update({
-        hash: "force-stitching"
-      }).whereIn("entity_id", chunk);
-      await knex.table("refresh_state").update({
-        result_hash: "force-stitching",
-        next_update_at: knex.fn.now()
-      }).whereIn("entity_id", chunk);
+      await knex
+        .table("final_entities")
+        .update({
+          hash: "force-stitching",
+        })
+        .whereIn("entity_id", chunk);
+      await knex
+        .table("refresh_state")
+        .update({
+          result_hash: "force-stitching",
+          next_update_at: knex.fn.now(),
+        })
+        .whereIn("entity_id", chunk);
     }
   } else if (mode === "deferred") {
     const ticket = uuid.v4();
     for (const chunk of entityRefs) {
-      await knex("refresh_state").update({
-        next_stitch_at: knex.fn.now(),
-        next_stitch_ticket: ticket
-      }).whereIn("entity_ref", chunk);
+      await knex("refresh_state")
+        .update({
+          next_stitch_at: knex.fn.now(),
+          next_stitch_ticket: ticket,
+        })
+        .whereIn("entity_ref", chunk);
     }
     for (const chunk of entityIds) {
-      await knex("refresh_state").update({
-        next_stitch_at: knex.fn.now(),
-        next_stitch_ticket: ticket
-      }).whereIn("entity_id", chunk);
+      await knex("refresh_state")
+        .update({
+          next_stitch_at: knex.fn.now(),
+          next_stitch_ticket: ticket,
+        })
+        .whereIn("entity_id", chunk);
     }
   } else {
     throw new Error(`Unknown stitching strategy mode ${mode}`);
@@ -1726,33 +1925,43 @@ function split(input) {
   if (!input) {
     return [];
   }
-  return splitToChunks__default.default(Array.isArray(input) ? input : [...input], 200);
+  return splitToChunks__default.default(
+    Array.isArray(input) ? input : [...input],
+    200
+  );
 }
 
 async function deleteOrphanedEntities(options) {
   const { knex, strategy } = options;
   let total = 0;
   for (let i = 0; i < 100; ++i) {
-    const candidates = await knex.with(
-      "orphans",
-      ["entity_id", "entity_ref"],
-      (orphans) => orphans.from("refresh_state").select("refresh_state.entity_id", "refresh_state.entity_ref").leftOuterJoin(
-        "refresh_state_references",
-        "refresh_state_references.target_entity_ref",
-        "refresh_state.entity_ref"
-      ).whereNull("refresh_state_references.target_entity_ref")
-    ).select({
-      entityId: "orphans.entity_id",
-      relationSourceId: "refresh_state.entity_id"
-    }).from("orphans").leftOuterJoin(
-      "relations",
-      "relations.target_entity_ref",
-      "orphans.entity_ref"
-    ).leftOuterJoin(
-      "refresh_state",
-      "refresh_state.entity_ref",
-      "relations.source_entity_ref"
-    );
+    const candidates = await knex
+      .with("orphans", ["entity_id", "entity_ref"], (orphans) =>
+        orphans
+          .from("refresh_state")
+          .select("refresh_state.entity_id", "refresh_state.entity_ref")
+          .leftOuterJoin(
+            "refresh_state_references",
+            "refresh_state_references.target_entity_ref",
+            "refresh_state.entity_ref"
+          )
+          .whereNull("refresh_state_references.target_entity_ref")
+      )
+      .select({
+        entityId: "orphans.entity_id",
+        relationSourceId: "refresh_state.entity_id",
+      })
+      .from("orphans")
+      .leftOuterJoin(
+        "relations",
+        "relations.target_entity_ref",
+        "orphans.entity_ref"
+      )
+      .leftOuterJoin(
+        "refresh_state",
+        "refresh_state.entity_ref",
+        "relations.source_entity_ref"
+      );
     if (!candidates.length) {
       break;
     }
@@ -1765,14 +1974,22 @@ async function deleteOrphanedEntities(options) {
     await markForStitching({
       knex,
       strategy,
-      entityIds: orphanRelationIds
+      entityIds: orphanRelationIds,
     });
   }
   return total;
 }
 
 var __defProp$8 = Object.defineProperty;
-var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$8 = (obj, key, value) =>
+  key in obj
+    ? __defProp$8(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$8 = (obj, key, value) => {
   __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
@@ -1804,8 +2021,10 @@ class DefaultCatalogProcessingEngine {
     this.orchestrator = options.orchestrator;
     this.stitcher = options.stitcher;
     this.createHash = options.createHash;
-    this.pollingIntervalMs = (_a = options.pollingIntervalMs) != null ? _a : 1e3;
-    this.orphanCleanupIntervalMs = (_b = options.orphanCleanupIntervalMs) != null ? _b : 3e4;
+    this.pollingIntervalMs =
+      (_a = options.pollingIntervalMs) != null ? _a : 1e3;
+    this.orphanCleanupIntervalMs =
+      (_b = options.orphanCleanupIntervalMs) != null ? _b : 3e4;
     this.onProcessingError = options.onProcessingError;
     this.tracker = (_c = options.tracker) != null ? _c : progressTracker$1();
     this.eventBroker = options.eventBroker;
@@ -1838,7 +2057,7 @@ class DefaultCatalogProcessingEngine {
           const { items } = await this.processingDatabase.transaction(
             async (tx) => {
               return this.processingDatabase.getProcessableEntities(tx, {
-                processBatchSize: count
+                processBatchSize: count,
               });
             }
           );
@@ -1860,23 +2079,26 @@ class DefaultCatalogProcessingEngine {
               unprocessedEntity,
               entityRef,
               locationKey,
-              resultHash: previousResultHash
+              resultHash: previousResultHash,
             } = item;
             const result = await this.orchestrator.process({
               entity: unprocessedEntity,
-              state
+              state,
             });
             track.markProcessorsCompleted(result);
             if (result.ok) {
               const { ttl: _, ...stateWithoutTtl } = state != null ? state : {};
-              if (stableStringify__default.default(stateWithoutTtl) !== stableStringify__default.default(result.state)) {
+              if (
+                stableStringify__default.default(stateWithoutTtl) !==
+                stableStringify__default.default(result.state)
+              ) {
                 await this.processingDatabase.transaction(async (tx) => {
                   await this.processingDatabase.updateEntityCache(tx, {
                     id,
                     state: {
                       ttl: CACHE_TTL,
-                      ...result.state
-                    }
+                      ...result.state,
+                    },
                   });
                 });
               }
@@ -1886,32 +2108,58 @@ class DefaultCatalogProcessingEngine {
               await this.processingDatabase.transaction(async (tx) => {
                 await this.processingDatabase.updateEntityCache(tx, {
                   id,
-                  state: ttl > 0 ? { ...state, ttl: ttl - 1 } : {}
+                  state: ttl > 0 ? { ...state, ttl: ttl - 1 } : {},
                 });
               });
             }
-            const location = (_b = (_a = unprocessedEntity == null ? void 0 : unprocessedEntity.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b[catalogModel.ANNOTATION_LOCATION];
+            const location =
+              (_b =
+                (_a =
+                  unprocessedEntity == null
+                    ? void 0
+                    : unprocessedEntity.metadata) == null
+                  ? void 0
+                  : _a.annotations) == null
+                ? void 0
+                : _b[catalogModel.ANNOTATION_LOCATION];
             if (result.errors.length) {
-              (_c = this.eventBroker) == null ? void 0 : _c.publish({
-                topic: CATALOG_ERRORS_TOPIC,
-                eventPayload: {
-                  entity: entityRef,
-                  location,
-                  errors: result.errors
-                }
-              });
+              console.warn(JSON.stringify(result.errors, null, 2));
+              (_c = this.eventBroker) == null
+                ? void 0
+                : _c.publish({
+                    topic: CATALOG_ERRORS_TOPIC,
+                    eventPayload: {
+                      entity: entityRef,
+                      location,
+                      errors: result.errors,
+                    },
+                  });
             }
             const errorsString = JSON.stringify(
               result.errors.map((e) => errors.serializeError(e))
             );
             let hashBuilder = this.createHash().update(errorsString);
             if (result.ok) {
-              const { entityRefs: parents } = await this.processingDatabase.transaction(
-                (tx) => this.processingDatabase.listParents(tx, {
-                  entityRef
-                })
-              );
-              hashBuilder = hashBuilder.update(stableStringify__default.default({ ...result.completedEntity })).update(stableStringify__default.default([...result.deferredEntities])).update(stableStringify__default.default([...result.relations])).update(stableStringify__default.default([...result.refreshKeys])).update(stableStringify__default.default([...parents]));
+              const { entityRefs: parents } =
+                await this.processingDatabase.transaction((tx) =>
+                  this.processingDatabase.listParents(tx, {
+                    entityRef,
+                  })
+                );
+              hashBuilder = hashBuilder
+                .update(
+                  stableStringify__default.default({
+                    ...result.completedEntity,
+                  })
+                )
+                .update(
+                  stableStringify__default.default([...result.deferredEntities])
+                )
+                .update(stableStringify__default.default([...result.relations]))
+                .update(
+                  stableStringify__default.default([...result.refreshKeys])
+                )
+                .update(stableStringify__default.default([...parents]));
             }
             const resultHash = hashBuilder.digest("hex");
             if (resultHash === previousResultHash) {
@@ -1919,30 +2167,34 @@ class DefaultCatalogProcessingEngine {
               return;
             }
             if (!result.ok) {
-              Promise.resolve(void 0).then(
-                () => {
+              Promise.resolve(void 0)
+                .then(() => {
                   var _a2;
-                  return (_a2 = this.onProcessingError) == null ? void 0 : _a2.call(this, {
-                    unprocessedEntity,
-                    errors: result.errors
-                  });
-                }
-              ).catch((error) => {
-                this.logger.debug(
-                  `Processing error listener threw an exception, ${errors.stringifyError(
-                    error
-                  )}`
-                );
-              });
+                  return (_a2 = this.onProcessingError) == null
+                    ? void 0
+                    : _a2.call(this, {
+                        unprocessedEntity,
+                        errors: result.errors,
+                      });
+                })
+                .catch((error) => {
+                  this.logger.debug(
+                    `Processing error listener threw an exception, ${errors.stringifyError(
+                      error
+                    )}`
+                  );
+                });
               await this.processingDatabase.transaction(async (tx) => {
                 await this.processingDatabase.updateProcessedEntityErrors(tx, {
                   id,
                   errors: errorsString,
-                  resultHash
+                  resultHash,
                 });
               });
               await this.stitcher.stitch({
-                entityRefs: [catalogModel.stringifyEntityRef(unprocessedEntity)]
+                entityRefs: [
+                  catalogModel.stringifyEntityRef(unprocessedEntity),
+                ],
               });
               track.markSuccessfulWithErrors();
               return;
@@ -1950,31 +2202,34 @@ class DefaultCatalogProcessingEngine {
             result.completedEntity.metadata.uid = id;
             let oldRelationSources;
             await this.processingDatabase.transaction(async (tx) => {
-              const { previous } = await this.processingDatabase.updateProcessedEntity(tx, {
-                id,
-                processedEntity: result.completedEntity,
-                resultHash,
-                errors: errorsString,
-                relations: result.relations,
-                deferredEntities: result.deferredEntities,
-                locationKey,
-                refreshKeys: result.refreshKeys
-              });
+              const { previous } =
+                await this.processingDatabase.updateProcessedEntity(tx, {
+                  id,
+                  processedEntity: result.completedEntity,
+                  resultHash,
+                  errors: errorsString,
+                  relations: result.relations,
+                  deferredEntities: result.deferredEntities,
+                  locationKey,
+                  refreshKeys: result.refreshKeys,
+                });
               oldRelationSources = new Map(
                 previous.relations.map((r) => [
                   `${r.source_entity_ref}:${r.type}`,
-                  r.source_entity_ref
+                  r.source_entity_ref,
                 ])
               );
             });
             const newRelationSources = new Map(
               result.relations.map((relation) => {
-                const sourceEntityRef = catalogModel.stringifyEntityRef(relation.source);
+                const sourceEntityRef = catalogModel.stringifyEntityRef(
+                  relation.source
+                );
                 return [`${sourceEntityRef}:${relation.type}`, sourceEntityRef];
               })
             );
             const setOfThingsToStitch = /* @__PURE__ */ new Set([
-              catalogModel.stringifyEntityRef(result.completedEntity)
+              catalogModel.stringifyEntityRef(result.completedEntity),
             ]);
             newRelationSources.forEach((sourceEntityRef, uniqueKey) => {
               if (!oldRelationSources.has(uniqueKey)) {
@@ -1987,7 +2242,7 @@ class DefaultCatalogProcessingEngine {
               }
             });
             await this.stitcher.stitch({
-              entityRefs: setOfThingsToStitch
+              entityRefs: setOfThingsToStitch,
             });
             track.markSuccessfulWithChanges();
           } catch (error) {
@@ -1995,22 +2250,24 @@ class DefaultCatalogProcessingEngine {
             track.markFailed(error);
           }
         });
-      }
+      },
     });
   }
   startOrphanCleanup() {
     var _a;
-    const orphanStrategy = (_a = this.config.getOptionalString("catalog.orphanStrategy")) != null ? _a : "keep";
+    const orphanStrategy =
+      (_a = this.config.getOptionalString("catalog.orphanStrategy")) != null
+        ? _a
+        : "keep";
     if (orphanStrategy !== "delete") {
-      return () => {
-      };
+      return () => {};
     }
     const stitchingStrategy = stitchingStrategyFromConfig(this.config);
     const runOnce = async () => {
       try {
         const n = await deleteOrphanedEntities({
           knex: this.knex,
-          strategy: stitchingStrategy
+          strategy: stitchingStrategy,
         });
         if (n > 0) {
           this.logger.info(`Deleted ${n} orphaned entities`);
@@ -2026,7 +2283,7 @@ class DefaultCatalogProcessingEngine {
         frequency: { milliseconds: this.orphanCleanupIntervalMs },
         timeout: { milliseconds: this.orphanCleanupIntervalMs * 0.8 },
         fn: runOnce,
-        signal: abortController.signal
+        signal: abortController.signal,
       });
       return () => {
         abortController.abort();
@@ -2042,21 +2299,21 @@ function progressTracker$1() {
   const promProcessedEntities = createCounterMetric({
     name: "catalog_processed_entities_count",
     help: "Amount of entities processed, DEPRECATED, use OpenTelemetry metrics instead",
-    labelNames: ["result"]
+    labelNames: ["result"],
   });
   const promProcessingDuration = createSummaryMetric({
     name: "catalog_processing_duration_seconds",
     help: "Time spent executing the full processing flow, DEPRECATED, use OpenTelemetry metrics instead",
-    labelNames: ["result"]
+    labelNames: ["result"],
   });
   const promProcessorsDuration = createSummaryMetric({
     name: "catalog_processors_duration_seconds",
     help: "Time spent executing catalog processors, DEPRECATED, use OpenTelemetry metrics instead",
-    labelNames: ["result"]
+    labelNames: ["result"],
   });
   const promProcessingQueueDelay = createSummaryMetric({
     name: "catalog_processing_queue_delay_seconds",
-    help: "The amount of delay between being scheduled for processing, and the start of actually being processed, DEPRECATED, use OpenTelemetry metrics instead"
+    help: "The amount of delay between being scheduled for processing, and the start of actually being processed, DEPRECATED, use OpenTelemetry metrics instead",
   });
   const meter = api.metrics.getMeter("default");
   const processedEntities = meter.createCounter(
@@ -2067,21 +2324,22 @@ function progressTracker$1() {
     "catalog.processing.duration",
     {
       description: "Time spent executing the full processing flow",
-      unit: "seconds"
+      unit: "seconds",
     }
   );
   const processorsDuration = meter.createHistogram(
     "catalog.processors.duration",
     {
       description: "Time spent executing catalog processors",
-      unit: "seconds"
+      unit: "seconds",
     }
   );
   const processingQueueDelay = meter.createHistogram(
     "catalog.processing.queue.delay",
     {
-      description: "The amount of delay between being scheduled for processing, and the start of actually being processed",
-      unit: "seconds"
+      description:
+        "The amount of delay between being scheduled for processing, and the start of actually being processed",
+      unit: "seconds",
     }
   );
   function processStart(item, logger) {
@@ -2101,7 +2359,7 @@ function progressTracker$1() {
     function markProcessorsCompleted(result) {
       endProcessorsTimer({ result: result.ok ? "ok" : "failed" });
       processorsDuration.record(endTime(), {
-        result: result.ok ? "ok" : "failed"
+        result: result.ok ? "ok" : "failed",
       });
     }
     function markSuccessfulWithNoChanges() {
@@ -2132,16 +2390,20 @@ function progressTracker$1() {
       markSuccessfulWithNoChanges,
       markSuccessfulWithErrors,
       markSuccessfulWithChanges,
-      markFailed
+      markFailed,
     };
   }
   return { processStart };
 }
 
 class DefaultLocationService {
-  constructor(store, orchestrator, options = {
-    allowedLocationTypes: ["url"]
-  }) {
+  constructor(
+    store,
+    orchestrator,
+    options = {
+      allowedLocationTypes: ["url"],
+    }
+  ) {
     this.store = store;
     this.orchestrator = orchestrator;
     this.options = options;
@@ -2170,7 +2432,9 @@ class DefaultLocationService {
     return this.store.deleteLocation(id);
   }
   getLocationByEntity(entityRef) {
-    return this.store.getLocationByEntity(catalogModel.parseEntityRef(entityRef));
+    return this.store.getLocationByEntity(
+      catalogModel.parseEntityRef(entityRef)
+    );
   }
   async processEntities(unprocessedEntities) {
     const entities = [];
@@ -2181,13 +2445,17 @@ class DefaultLocationService {
       }
       const processed = await this.orchestrator.process({
         entity: currentEntity.entity,
-        state: {}
+        state: {},
         // we process without the existing cache
       });
       if (processed.ok) {
-        if (entities.some(
-          (e) => catalogModel.stringifyEntityRef(e) === catalogModel.stringifyEntityRef(processed.completedEntity)
-        )) {
+        if (
+          entities.some(
+            (e) =>
+              catalogModel.stringifyEntityRef(e) ===
+              catalogModel.stringifyEntityRef(processed.completedEntity)
+          )
+        ) {
           throw new errors.InputError(
             `Duplicate nested entity: ${catalogModel.stringifyEntityRef(
               processed.completedEntity
@@ -2203,36 +2471,38 @@ class DefaultLocationService {
     return entities;
   }
   async dryRunCreateLocation(spec) {
-    const existsPromise = this.store.listLocations().then(
-      (locations) => locations.some((l) => l.type === spec.type && l.target === spec.target)
-    );
+    const existsPromise = this.store
+      .listLocations()
+      .then((locations) =>
+        locations.some((l) => l.type === spec.type && l.target === spec.target)
+      );
     const entity = {
       apiVersion: "backstage.io/v1alpha1",
       kind: "Location",
       metadata: {
         name: locationSpecToMetadataName({
           type: spec.type,
-          target: spec.target
+          target: spec.target,
         }),
         namespace: "default",
         annotations: {
           [catalogModel.ANNOTATION_LOCATION]: `${spec.type}:${spec.target}`,
-          [catalogModel.ANNOTATION_ORIGIN_LOCATION]: `${spec.type}:${spec.target}`
-        }
+          [catalogModel.ANNOTATION_ORIGIN_LOCATION]: `${spec.type}:${spec.target}`,
+        },
       },
       spec: {
         type: spec.type,
-        target: spec.target
-      }
+        target: spec.target,
+      },
     };
     const unprocessedEntities = [
-      { entity, locationKey: `${spec.type}:${spec.target}` }
+      { entity, locationKey: `${spec.type}:${spec.target}` },
     ];
     const entities = await this.processEntities(unprocessedEntities);
     return {
       exists: await existsPromise,
       location: { ...spec, id: `${spec.type}:${spec.target}` },
-      entities
+      entities,
     };
   }
 }
@@ -2254,11 +2524,16 @@ async function requireRequestBody(req) {
   }
   return body;
 }
-const locationInput = zod.z.object({
-  type: zod.z.string(),
-  target: zod.z.string(),
-  presence: zod.z.literal("required").or(zod.z.literal("optional")).optional()
-}).strict();
+const locationInput = zod.z
+  .object({
+    type: zod.z.string(),
+    target: zod.z.string(),
+    presence: zod.z
+      .literal("required")
+      .or(zod.z.literal("optional"))
+      .optional(),
+  })
+  .strict();
 async function validateRequestBody(req, schema) {
   const body = await requireRequestBody(req);
   try {
@@ -2269,7 +2544,9 @@ async function validateRequestBody(req, schema) {
 }
 function disallowReadonlyMode(readonly) {
   if (readonly) {
-    throw new errors.NotAllowedError("This operation not allowed in readonly mode");
+    throw new errors.NotAllowedError(
+      "This operation not allowed in readonly mode"
+    );
   }
 }
 function isQueryEntitiesInitialRequest(input) {
@@ -2284,26 +2561,32 @@ function isQueryEntitiesCursorRequest(input) {
   }
   return !!input.cursor;
 }
-const entityFilterParser$1 = zod.z.lazy(
-  () => zod.z.object({
-    key: zod.z.string(),
-    values: zod.z.array(zod.z.string()).optional()
-  }).or(zod.z.object({ not: entityFilterParser$1 })).or(zod.z.object({ anyOf: zod.z.array(entityFilterParser$1) })).or(zod.z.object({ allOf: zod.z.array(entityFilterParser$1) }))
+const entityFilterParser$1 = zod.z.lazy(() =>
+  zod.z
+    .object({
+      key: zod.z.string(),
+      values: zod.z.array(zod.z.string()).optional(),
+    })
+    .or(zod.z.object({ not: entityFilterParser$1 }))
+    .or(zod.z.object({ anyOf: zod.z.array(entityFilterParser$1) }))
+    .or(zod.z.object({ allOf: zod.z.array(entityFilterParser$1) }))
 );
 const cursorParser = zod.z.object({
   orderFields: zod.z.array(
     zod.z.object({ field: zod.z.string(), order: zod.z.enum(["asc", "desc"]) })
   ),
-  fullTextFilter: zod.z.object({
-    term: zod.z.string(),
-    fields: zod.z.array(zod.z.string()).optional()
-  }).optional(),
+  fullTextFilter: zod.z
+    .object({
+      term: zod.z.string(),
+      fields: zod.z.array(zod.z.string()).optional(),
+    })
+    .optional(),
   orderFieldValues: zod.z.array(zod.z.string().or(zod.z.null())),
   filter: entityFilterParser$1.optional(),
   isPrevious: zod.z.boolean(),
   query: zod.z.string().optional(),
   firstSortFieldValues: zod.z.array(zod.z.string().or(zod.z.null())).optional(),
-  totalItems: zod.z.number().optional()
+  totalItems: zod.z.number().optional(),
 });
 function encodeCursor(cursor) {
   const json = JSON.stringify(cursor);
@@ -2323,14 +2606,22 @@ function decodeCursor(encodedCursor) {
 }
 
 var __defProp$7 = Object.defineProperty;
-var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$7 = (obj, key, value) =>
+  key in obj
+    ? __defProp$7(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$7 = (obj, key, value) => {
   __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
 };
 const defaultSortField = {
   field: "metadata.uid",
-  order: "asc"
+  order: "asc",
 };
 const DEFAULT_LIMIT = 20;
 function parsePagination(input) {
@@ -2350,13 +2641,17 @@ function parsePagination(input) {
   }
   if (cursor.limit !== void 0) {
     if (!Number.isInteger(cursor.limit)) {
-      throw new errors.InputError("Malformed after cursor, limit was not an number");
+      throw new errors.InputError(
+        "Malformed after cursor, limit was not an number"
+      );
     }
     limit = cursor.limit;
   }
   if (cursor.offset !== void 0) {
     if (!Number.isInteger(cursor.offset)) {
-      throw new errors.InputError("Malformed after cursor, offset was not a number");
+      throw new errors.InputError(
+        "Malformed after cursor, offset was not a number"
+      );
     }
     offset = cursor.offset;
   }
@@ -2368,17 +2663,27 @@ function stringifyPagination(input) {
   const base64 = Buffer.from(json, "utf8").toString("base64");
   return base64;
 }
-function addCondition(queryBuilder, db, filter, negate = false, entityIdField = "entity_id") {
+function addCondition(
+  queryBuilder,
+  db,
+  filter,
+  negate = false,
+  entityIdField = "entity_id"
+) {
   var _a;
   const key = filter.key.toLowerCase();
-  const values = (_a = filter.values) == null ? void 0 : _a.map((v) => v.toLowerCase());
-  const matchQuery = db("search").select("search.entity_id").where({ key }).andWhere(function keyFilter() {
-    if ((values == null ? void 0 : values.length) === 1) {
-      this.where({ value: values.at(0) });
-    } else if (values) {
-      this.andWhere("value", "in", values);
-    }
-  });
+  const values =
+    (_a = filter.values) == null ? void 0 : _a.map((v) => v.toLowerCase());
+  const matchQuery = db("search")
+    .select("search.entity_id")
+    .where({ key })
+    .andWhere(function keyFilter() {
+      if ((values == null ? void 0 : values.length) === 1) {
+        this.where({ value: values.at(0) });
+      } else if (values) {
+        this.andWhere("value", "in", values);
+      }
+    });
   queryBuilder.andWhere(entityIdField, negate ? "not in" : "in", matchQuery);
 }
 function isEntitiesSearchFilter(filter) {
@@ -2390,7 +2695,13 @@ function isOrEntityFilter(filter) {
 function isNegationEntityFilter(filter) {
   return filter.hasOwnProperty("not");
 }
-function parseFilter(filter, query, db, negate = false, entityIdField = "entity_id") {
+function parseFilter(
+  filter,
+  query,
+  db,
+  negate = false,
+  entityIdField = "entity_id"
+) {
   if (isNegationEntityFilter(filter)) {
     return parseFilter(filter.not, query, db, !negate, entityIdField);
   }
@@ -2403,14 +2714,14 @@ function parseFilter(filter, query, db, negate = false, entityIdField = "entity_
     var _a, _b;
     if (isOrEntityFilter(filter)) {
       for (const subFilter of (_a = filter.anyOf) != null ? _a : []) {
-        this.orWhere(
-          (subQuery) => parseFilter(subFilter, subQuery, db, false, entityIdField)
+        this.orWhere((subQuery) =>
+          parseFilter(subFilter, subQuery, db, false, entityIdField)
         );
       }
     } else {
       for (const subFilter of (_b = filter.allOf) != null ? _b : []) {
-        this.andWhere(
-          (subQuery) => parseFilter(subFilter, subQuery, db, false, entityIdField)
+        this.andWhere((subQuery) =>
+          parseFilter(subFilter, subQuery, db, false, entityIdField)
         );
       }
     }
@@ -2429,15 +2740,19 @@ class DefaultEntitiesCatalog {
     var _a, _b;
     const db = this.database;
     let entitiesQuery = db("final_entities").select("final_entities.*");
-    (_a = request == null ? void 0 : request.order) == null ? void 0 : _a.forEach(({ field }, index) => {
-      const alias = `order_${index}`;
-      entitiesQuery = entitiesQuery.leftOuterJoin(
-        { [alias]: "search" },
-        function search(inner) {
-          inner.on(`${alias}.entity_id`, "final_entities.entity_id").andOn(`${alias}.key`, db.raw("?", [field]));
-        }
-      );
-    });
+    (_a = request == null ? void 0 : request.order) == null
+      ? void 0
+      : _a.forEach(({ field }, index) => {
+          const alias = `order_${index}`;
+          entitiesQuery = entitiesQuery.leftOuterJoin(
+            { [alias]: "search" },
+            function search(inner) {
+              inner
+                .on(`${alias}.entity_id`, "final_entities.entity_id")
+                .andOn(`${alias}.key`, db.raw("?", [field]));
+            }
+          );
+        });
     entitiesQuery = entitiesQuery.whereNotNull("final_entities.final_entity");
     if (request == null ? void 0 : request.filter) {
       entitiesQuery = parseFilter(
@@ -2448,20 +2763,24 @@ class DefaultEntitiesCatalog {
         "final_entities.entity_id"
       );
     }
-    (_b = request == null ? void 0 : request.order) == null ? void 0 : _b.forEach(({ order }, index) => {
-      if (db.client.config.client === "pg") {
-        entitiesQuery = entitiesQuery.orderBy([
-          { column: `order_${index}.value`, order, nulls: "last" }
-        ]);
-      } else {
-        entitiesQuery = entitiesQuery.orderBy([
-          { column: `order_${index}.value`, order: void 0, nulls: "last" },
-          { column: `order_${index}.value`, order }
-        ]);
-      }
-    });
+    (_b = request == null ? void 0 : request.order) == null
+      ? void 0
+      : _b.forEach(({ order }, index) => {
+          if (db.client.config.client === "pg") {
+            entitiesQuery = entitiesQuery.orderBy([
+              { column: `order_${index}.value`, order, nulls: "last" },
+            ]);
+          } else {
+            entitiesQuery = entitiesQuery.orderBy([
+              { column: `order_${index}.value`, order: void 0, nulls: "last" },
+              { column: `order_${index}.value`, order },
+            ]);
+          }
+        });
     entitiesQuery = entitiesQuery.orderBy("final_entities.entity_id", "asc");
-    const { limit, offset } = parsePagination(request == null ? void 0 : request.pagination);
+    const { limit, offset } = parsePagination(
+      request == null ? void 0 : request.pagination
+    );
     if (limit !== void 0) {
       entitiesQuery = entitiesQuery.limit(limit + 1);
     }
@@ -2478,8 +2797,8 @@ class DefaultEntitiesCatalog {
         hasNextPage: true,
         endCursor: stringifyPagination({
           limit,
-          offset: (offset != null ? offset : 0) + limit
-        })
+          offset: (offset != null ? offset : 0) + limit,
+        }),
       };
     }
     let entities = rows.map((e) => JSON.parse(e.final_entity));
@@ -2490,7 +2809,9 @@ class DefaultEntitiesCatalog {
       if (entity.relations) {
         for (const relation of entity.relations) {
           if (!relation.targetRef && relation.target) {
-            relation.targetRef = catalogModel.stringifyEntityRef(relation.target);
+            relation.targetRef = catalogModel.stringifyEntityRef(
+              relation.target
+            );
           } else if (!relation.target && relation.targetRef) {
             relation.target = catalogModel.parseEntityRef(relation.targetRef);
           }
@@ -2499,20 +2820,23 @@ class DefaultEntitiesCatalog {
     }
     return {
       entities,
-      pageInfo
+      pageInfo,
     };
   }
   async entitiesBatch(request) {
     const lookup = /* @__PURE__ */ new Map();
     for (const chunk of lodash.chunk(request.entityRefs, 200)) {
-      let query = this.database("final_entities").innerJoin(
-        "refresh_state",
-        "refresh_state.entity_id",
-        "final_entities.entity_id"
-      ).select({
-        entityRef: "refresh_state.entity_ref",
-        entity: "final_entities.final_entity"
-      }).whereIn("refresh_state.entity_ref", chunk);
+      let query = this.database("final_entities")
+        .innerJoin(
+          "refresh_state",
+          "refresh_state.entity_id",
+          "final_entities.entity_id"
+        )
+        .select({
+          entityRef: "refresh_state.entity_ref",
+          entity: "final_entities.final_entity",
+        })
+        .whereIn("refresh_state.entity_ref", chunk);
       if (request == null ? void 0 : request.filter) {
         query = parseFilter(
           request.filter,
@@ -2542,7 +2866,7 @@ class DefaultEntitiesCatalog {
     const cursor = {
       orderFields: [defaultSortField],
       isPrevious: false,
-      ...parseCursorFromRequest(request)
+      ...parseCursorFromRequest(request),
     };
     const isFetchingBackwards = cursor.isPrevious;
     if (cursor.orderFields.length > 1) {
@@ -2550,28 +2874,43 @@ class DefaultEntitiesCatalog {
     }
     const sortField = {
       ...defaultSortField,
-      ...cursor.orderFields[0]
+      ...cursor.orderFields[0],
     };
-    const [prevItemOrderFieldValue, prevItemUid] = cursor.orderFieldValues || [];
-    const dbQuery = db("search").join("final_entities", "search.entity_id", "final_entities.entity_id").where("search.key", sortField.field);
+    const [prevItemOrderFieldValue, prevItemUid] =
+      cursor.orderFieldValues || [];
+    const dbQuery = db("search")
+      .join("final_entities", "search.entity_id", "final_entities.entity_id")
+      .where("search.key", sortField.field);
     if (cursor.filter) {
       parseFilter(cursor.filter, dbQuery, db, false, "search.entity_id");
     }
-    const normalizedFullTextFilterTerm = (_c = (_b = cursor.fullTextFilter) == null ? void 0 : _b.term) == null ? void 0 : _c.trim();
-    const textFilterFields = (_e = (_d = cursor.fullTextFilter) == null ? void 0 : _d.fields) != null ? _e : [sortField.field];
+    const normalizedFullTextFilterTerm =
+      (_c = (_b = cursor.fullTextFilter) == null ? void 0 : _b.term) == null
+        ? void 0
+        : _c.trim();
+    const textFilterFields =
+      (_e = (_d = cursor.fullTextFilter) == null ? void 0 : _d.fields) != null
+        ? _e
+        : [sortField.field];
     if (normalizedFullTextFilterTerm) {
-      if (textFilterFields.length === 1 && textFilterFields[0] === sortField.field) {
+      if (
+        textFilterFields.length === 1 &&
+        textFilterFields[0] === sortField.field
+      ) {
         dbQuery.andWhereRaw(
           "value like ?",
           `%${normalizedFullTextFilterTerm.toLocaleLowerCase("en-US")}%`
         );
       } else {
-        const matchQuery = db("search").select("search.entity_id").whereIn("key", textFilterFields).andWhere(function keyFilter() {
-          this.andWhereRaw(
-            "value like ?",
-            `%${normalizedFullTextFilterTerm.toLocaleLowerCase("en-US")}%`
-          );
-        });
+        const matchQuery = db("search")
+          .select("search.entity_id")
+          .whereIn("key", textFilterFields)
+          .andWhere(function keyFilter() {
+            this.andWhereRaw(
+              "value like ?",
+              `%${normalizedFullTextFilterTerm.toLocaleLowerCase("en-US")}%`
+            );
+          });
         dbQuery.andWhere("search.entity_id", "in", matchQuery);
       }
     }
@@ -2583,23 +2922,31 @@ class DefaultEntitiesCatalog {
           "value",
           isFetchingBackwards !== isOrderingDescending ? "<" : ">",
           prevItemOrderFieldValue
-        ).orWhere("value", "=", prevItemOrderFieldValue).andWhere(
-          "search.entity_id",
-          isFetchingBackwards !== isOrderingDescending ? "<" : ">",
-          prevItemUid
-        );
+        )
+          .orWhere("value", "=", prevItemOrderFieldValue)
+          .andWhere(
+            "search.entity_id",
+            isFetchingBackwards !== isOrderingDescending ? "<" : ">",
+            prevItemUid
+          );
       });
     }
-    dbQuery.orderBy([
-      {
-        column: "value",
-        order: isFetchingBackwards ? invertOrder(sortField.order) : sortField.order
-      },
-      {
-        column: "search.entity_id",
-        order: isFetchingBackwards ? invertOrder(sortField.order) : sortField.order
-      }
-    ]).limit(isFetchingBackwards ? limit : limit + 1);
+    dbQuery
+      .orderBy([
+        {
+          column: "value",
+          order: isFetchingBackwards
+            ? invertOrder(sortField.order)
+            : sortField.order,
+        },
+        {
+          column: "search.entity_id",
+          order: isFetchingBackwards
+            ? invertOrder(sortField.order)
+            : sortField.order,
+        },
+      ])
+      .limit(isFetchingBackwards ? limit : limit + 1);
     countQuery.count("search.entity_id", { as: "count" });
     const [rows, [{ count }]] = await Promise.all([
       limit > 0 ? dbQuery : [],
@@ -2607,13 +2954,16 @@ class DefaultEntitiesCatalog {
       // only on the first request.
       // The result is then embedded into the cursor
       // for subsequent requests.
-      typeof cursor.totalItems === "undefined" ? countQuery : [{ count: cursor.totalItems }]
+      typeof cursor.totalItems === "undefined"
+        ? countQuery
+        : [{ count: cursor.totalItems }],
     ]);
     const totalItems = Number(count);
     if (isFetchingBackwards) {
       rows.reverse();
     }
-    const hasMoreResults = limit > 0 && (isFetchingBackwards || rows.length > limit);
+    const hasMoreResults =
+      limit > 0 && (isFetchingBackwards || rows.length > limit);
     if (rows.length > limit) {
       rows.length -= 1;
     }
@@ -2622,81 +2972,114 @@ class DefaultEntitiesCatalog {
     const lastRow = rows[rows.length - 1];
     const firstSortFieldValues = cursor.firstSortFieldValues || [
       firstRow == null ? void 0 : firstRow.value,
-      firstRow == null ? void 0 : firstRow.entity_id
+      firstRow == null ? void 0 : firstRow.entity_id,
     ];
-    const nextCursor = hasMoreResults ? {
-      ...cursor,
-      orderFieldValues: sortFieldsFromRow(lastRow),
-      firstSortFieldValues,
-      isPrevious: false,
-      totalItems
-    } : void 0;
-    const prevCursor = !isInitialRequest && rows.length > 0 && !lodash.isEqual(sortFieldsFromRow(firstRow), cursor.firstSortFieldValues) ? {
-      ...cursor,
-      orderFieldValues: sortFieldsFromRow(firstRow),
-      firstSortFieldValues: cursor.firstSortFieldValues,
-      isPrevious: true,
-      totalItems
-    } : void 0;
-    const items = rows.map((e) => JSON.parse(e.final_entity)).map((e) => request.fields ? request.fields(e) : e);
+    const nextCursor = hasMoreResults
+      ? {
+          ...cursor,
+          orderFieldValues: sortFieldsFromRow(lastRow),
+          firstSortFieldValues,
+          isPrevious: false,
+          totalItems,
+        }
+      : void 0;
+    const prevCursor =
+      !isInitialRequest &&
+      rows.length > 0 &&
+      !lodash.isEqual(sortFieldsFromRow(firstRow), cursor.firstSortFieldValues)
+        ? {
+            ...cursor,
+            orderFieldValues: sortFieldsFromRow(firstRow),
+            firstSortFieldValues: cursor.firstSortFieldValues,
+            isPrevious: true,
+            totalItems,
+          }
+        : void 0;
+    const items = rows
+      .map((e) => JSON.parse(e.final_entity))
+      .map((e) => (request.fields ? request.fields(e) : e));
     return {
       items,
       pageInfo: {
-        ...!!prevCursor && { prevCursor },
-        ...!!nextCursor && { nextCursor }
+        ...(!!prevCursor && { prevCursor }),
+        ...(!!nextCursor && { nextCursor }),
       },
-      totalItems
+      totalItems,
     };
   }
   async removeEntityByUid(uid) {
     const dbConfig = this.database.client.config;
     if (dbConfig.client.includes("mysql")) {
-      const results = await this.database("refresh_state").select("entity_id").whereIn("entity_ref", function parents(builder) {
-        return builder.from("refresh_state").innerJoin(
-          "refresh_state_references",
-          {
-            "refresh_state_references.target_entity_ref": "refresh_state.entity_ref"
-          }
-        ).where("refresh_state.entity_id", "=", uid).select("refresh_state_references.source_entity_ref");
-      });
-      await this.database("refresh_state").update({
-        result_hash: "child-was-deleted",
-        next_update_at: this.database.fn.now()
-      }).whereIn(
-        "entity_id",
-        results.map((key) => key.entity_id)
-      );
+      const results = await this.database("refresh_state")
+        .select("entity_id")
+        .whereIn("entity_ref", function parents(builder) {
+          return builder
+            .from("refresh_state")
+            .innerJoin("refresh_state_references", {
+              "refresh_state_references.target_entity_ref":
+                "refresh_state.entity_ref",
+            })
+            .where("refresh_state.entity_id", "=", uid)
+            .select("refresh_state_references.source_entity_ref");
+        });
+      await this.database("refresh_state")
+        .update({
+          result_hash: "child-was-deleted",
+          next_update_at: this.database.fn.now(),
+        })
+        .whereIn(
+          "entity_id",
+          results.map((key) => key.entity_id)
+        );
     } else {
-      await this.database("refresh_state").update({
-        result_hash: "child-was-deleted",
-        next_update_at: this.database.fn.now()
-      }).whereIn("entity_ref", function parents(builder) {
-        return builder.from("refresh_state").innerJoin(
-          "refresh_state_references",
-          {
-            "refresh_state_references.target_entity_ref": "refresh_state.entity_ref"
-          }
-        ).where("refresh_state.entity_id", "=", uid).select("refresh_state_references.source_entity_ref");
-      });
+      await this.database("refresh_state")
+        .update({
+          result_hash: "child-was-deleted",
+          next_update_at: this.database.fn.now(),
+        })
+        .whereIn("entity_ref", function parents(builder) {
+          return builder
+            .from("refresh_state")
+            .innerJoin("refresh_state_references", {
+              "refresh_state_references.target_entity_ref":
+                "refresh_state.entity_ref",
+            })
+            .where("refresh_state.entity_id", "=", uid)
+            .select("refresh_state_references.source_entity_ref");
+        });
     }
-    const relationPeers = await this.database.from("relations").innerJoin("refresh_state", {
-      "refresh_state.entity_ref": "relations.target_entity_ref"
-    }).where("relations.originating_entity_id", "=", uid).andWhere("refresh_state.entity_id", "!=", uid).select({ ref: "relations.target_entity_ref" }).union(
-      (other) => other.from("relations").innerJoin("refresh_state", {
-        "refresh_state.entity_ref": "relations.source_entity_ref"
-      }).where("relations.originating_entity_id", "=", uid).andWhere("refresh_state.entity_id", "!=", uid).select({ ref: "relations.source_entity_ref" })
-    );
+    const relationPeers = await this.database
+      .from("relations")
+      .innerJoin("refresh_state", {
+        "refresh_state.entity_ref": "relations.target_entity_ref",
+      })
+      .where("relations.originating_entity_id", "=", uid)
+      .andWhere("refresh_state.entity_id", "!=", uid)
+      .select({ ref: "relations.target_entity_ref" })
+      .union((other) =>
+        other
+          .from("relations")
+          .innerJoin("refresh_state", {
+            "refresh_state.entity_ref": "relations.source_entity_ref",
+          })
+          .where("relations.originating_entity_id", "=", uid)
+          .andWhere("refresh_state.entity_id", "!=", uid)
+          .select({ ref: "relations.source_entity_ref" })
+      );
     await this.database("refresh_state").where("entity_id", uid).delete();
     await this.stitcher.stitch({
-      entityRefs: new Set(relationPeers.map((p) => p.ref))
+      entityRefs: new Set(relationPeers.map((p) => p.ref)),
     });
   }
   async entityAncestry(rootRef) {
-    const [rootRow] = await this.database("refresh_state").leftJoin("final_entities", {
-      "refresh_state.entity_id": "final_entities.entity_id"
-    }).where("refresh_state.entity_ref", "=", rootRef).select({
-      entityJson: "final_entities.final_entity"
-    });
+    const [rootRow] = await this.database("refresh_state")
+      .leftJoin("final_entities", {
+        "refresh_state.entity_id": "final_entities.entity_id",
+      })
+      .where("refresh_state.entity_ref", "=", rootRef)
+      .select({
+        entityJson: "final_entities.final_entity",
+      });
     if (!rootRow) {
       throw new errors.NotFoundError(`No such entity ${rootRef}`);
     }
@@ -2707,16 +3090,19 @@ class DefaultEntitiesCatalog {
     for (let current = rootEntity; current; current = todo.pop()) {
       const currentRef = catalogModel.stringifyEntityRef(current);
       seenEntityRefs.add(currentRef);
-      const parentRows = await this.database(
-        "refresh_state_references"
-      ).innerJoin("refresh_state", {
-        "refresh_state_references.source_entity_ref": "refresh_state.entity_ref"
-      }).innerJoin("final_entities", {
-        "refresh_state.entity_id": "final_entities.entity_id"
-      }).where("refresh_state_references.target_entity_ref", "=", currentRef).select({
-        parentEntityRef: "refresh_state.entity_ref",
-        parentEntityJson: "final_entities.final_entity"
-      });
+      const parentRows = await this.database("refresh_state_references")
+        .innerJoin("refresh_state", {
+          "refresh_state_references.source_entity_ref":
+            "refresh_state.entity_ref",
+        })
+        .innerJoin("final_entities", {
+          "refresh_state.entity_id": "final_entities.entity_id",
+        })
+        .where("refresh_state_references.target_entity_ref", "=", currentRef)
+        .select({
+          parentEntityRef: "refresh_state.entity_ref",
+          parentEntityJson: "final_entities.final_entity",
+        });
       const parentRefs = [];
       for (const { parentEntityRef, parentEntityJson } of parentRows) {
         parentRefs.push(parentEntityRef);
@@ -2727,36 +3113,44 @@ class DefaultEntitiesCatalog {
       }
       items.push({
         entity: current,
-        parentEntityRefs: parentRefs
+        parentEntityRefs: parentRefs,
       });
     }
     return {
       rootEntityRef: catalogModel.stringifyEntityRef(rootEntity),
-      items
+      items,
     };
   }
   async facets(request) {
     const facets = {};
     const db = this.database;
     for (const facet of request.facets) {
-      const dbQuery = db("search").where("search.key", facet.toLocaleLowerCase("en-US")).whereNotNull("search.original_value").select({ value: "search.original_value", count: db.raw("count(*)") }).groupBy("search.original_value");
+      const dbQuery = db("search")
+        .where("search.key", facet.toLocaleLowerCase("en-US"))
+        .whereNotNull("search.original_value")
+        .select({ value: "search.original_value", count: db.raw("count(*)") })
+        .groupBy("search.original_value");
       if (request == null ? void 0 : request.filter) {
         parseFilter(request.filter, dbQuery, db, false, "search.entity_id");
       }
       const result = await dbQuery;
       facets[facet] = result.map((data) => ({
         value: String(data.value),
-        count: Number(data.count)
+        count: Number(data.count),
       }));
     }
     return { facets };
   }
 }
-const entityFilterParser = zod.z.lazy(
-  () => zod.z.object({
-    key: zod.z.string(),
-    values: zod.z.array(zod.z.string()).optional()
-  }).or(zod.z.object({ not: entityFilterParser })).or(zod.z.object({ anyOf: zod.z.array(entityFilterParser) })).or(zod.z.object({ allOf: zod.z.array(entityFilterParser) }))
+const entityFilterParser = zod.z.lazy(() =>
+  zod.z
+    .object({
+      key: zod.z.string(),
+      values: zod.z.array(zod.z.string()).optional(),
+    })
+    .or(zod.z.object({ not: entityFilterParser }))
+    .or(zod.z.object({ anyOf: zod.z.array(entityFilterParser) }))
+    .or(zod.z.object({ allOf: zod.z.array(entityFilterParser) }))
 );
 zod.z.object({
   orderFields: zod.z.array(
@@ -2767,14 +3161,14 @@ zod.z.object({
   isPrevious: zod.z.boolean(),
   query: zod.z.string().optional(),
   firstSortFieldValues: zod.z.array(zod.z.string().or(zod.z.null())).optional(),
-  totalItems: zod.z.number().optional()
+  totalItems: zod.z.number().optional(),
 });
 function parseCursorFromRequest(request) {
   if (isQueryEntitiesInitialRequest(request)) {
     const {
       filter,
       orderFields: sortFields = [defaultSortField],
-      fullTextFilter
+      fullTextFilter,
     } = request;
     return { filter, orderFields: sortFields, fullTextFilter };
   }
@@ -2791,7 +3185,15 @@ function sortFieldsFromRow(row) {
 }
 
 var __defProp$6 = Object.defineProperty;
-var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$6 = (obj, key, value) =>
+  key in obj
+    ? __defProp$6(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$6 = (obj, key, value) => {
   __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
@@ -2811,7 +3213,7 @@ class ProcessorOutputCollector {
   }
   forProcessor(processor) {
     const logger = this.logger.child({
-      processor: processor.getProcessorName()
+      processor: processor.getProcessorName(),
     });
     return (i) => this.receive(logger, i);
   }
@@ -2821,13 +3223,17 @@ class ProcessorOutputCollector {
       errors: this.errors,
       relations: this.relations,
       refreshKeys: this.refreshKeys,
-      deferredEntities: this.deferredEntities
+      deferredEntities: this.deferredEntities,
     };
   }
   receive(logger, i) {
     if (this.done) {
       logger.warn(
-        `Item of type "${i.type}" was emitted after processing had completed. Stack trace: ${new Error().stack}`
+        `Item of type "${
+          i.type
+        }" was emitted after processing had completed. Stack trace: ${
+          new Error().stack
+        }`
       );
       return;
     }
@@ -2859,16 +3265,16 @@ class ProcessorOutputCollector {
             annotations: {
               ...annotations,
               [catalogModel.ANNOTATION_ORIGIN_LOCATION]: originLocation,
-              [catalogModel.ANNOTATION_LOCATION]: location
-            }
-          }
+              [catalogModel.ANNOTATION_LOCATION]: location,
+            },
+          },
         };
       }
       this.deferredEntities.push({ entity, locationKey: location });
     } else if (i.type === "location") {
       const entity = locationSpecToLocationEntity({
         location: i.location,
-        parentEntity: this.parentEntity
+        parentEntity: this.parentEntity,
       });
       const locationKey = getEntityLocationRef(entity);
       this.deferredEntities.push({ entity, locationKey });
@@ -2883,7 +3289,15 @@ class ProcessorOutputCollector {
 }
 
 var __defProp$5 = Object.defineProperty;
-var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$5 = (obj, key, value) =>
+  key in obj
+    ? __defProp$5(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$5 = (obj, key, value) => {
   __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
@@ -3012,9 +3426,11 @@ class DefaultCatalogProcessingOrchestrator {
       const context = {
         entityRef: catalogModel.stringifyEntityRef(entity),
         location: catalogModel.parseLocationRef(getEntityLocationRef(entity)),
-        originLocation: catalogModel.parseLocationRef(getEntityOriginLocationRef(entity)),
+        originLocation: catalogModel.parseLocationRef(
+          getEntityOriginLocationRef(entity)
+        ),
         cache,
-        collector
+        collector,
       };
       entity = await this.runPreProcessStep(entity, context);
       entity = await this.runPolicyStep(entity);
@@ -3025,10 +3441,12 @@ class DefaultCatalogProcessingOrchestrator {
       entity = await this.runPostProcessStep(entity, context);
       const collectorResults = context.collector.results();
       for (const deferredEntity of collectorResults.deferredEntities) {
-        if (!this.options.rulesEnforcer.isAllowed(
-          deferredEntity.entity,
-          context.originLocation
-        )) {
+        if (
+          !this.options.rulesEnforcer.isAllowed(
+            deferredEntity.entity,
+            context.originLocation
+          )
+        ) {
           throw new errors.NotAllowedError(
             `Entity ${catalogModel.stringifyEntityRef(
               deferredEntity.entity
@@ -3044,246 +3462,283 @@ class DefaultCatalogProcessingOrchestrator {
         ...collectorResults,
         completedEntity: entity,
         state: { cache: cache.collect() },
-        ok: collectorResults.errors.length === 0
+        ok: collectorResults.errors.length === 0,
       };
     } catch (error) {
       errors.assertError(error);
       return {
         ok: false,
-        errors: collector.results().errors.concat(error)
+        errors: collector.results().errors.concat(error),
       };
     }
   }
   // Pre-process phase, used to populate entities with data that is required
   // during the main processing step
   async runPreProcessStep(entity, context) {
-    return await withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
-      addEntityAttributes(stageSpan, entity);
-      stageSpan.setAttribute("backstage.catalog.processor.stage", "preProcess");
-      let res = entity;
-      for (const processor of this.options.processors) {
-        if (processor.preProcessEntity) {
-          let innerRes = res;
-          res = await withActiveSpan(tracer, "ProcessingStep", async (span) => {
-            addEntityAttributes(span, entity);
-            addProcessorAttributes(span, "preProcessEntity", processor);
-            try {
-              innerRes = await processor.preProcessEntity(
-                innerRes,
-                context.location,
-                context.collector.forProcessor(processor),
-                context.originLocation,
-                context.cache.forProcessor(processor)
-              );
-            } catch (e) {
-              throw new errors.InputError(
-                `Processor ${processor.constructor.name} threw an error while preprocessing`,
-                e
-              );
-            }
-            return innerRes;
-          });
-        }
-      }
-      return res;
-    });
-  }
-  /**
-   * Enforce entity policies making sure that entities conform to a general schema
-   */
-  async runPolicyStep(entity) {
-    return await withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
-      addEntityAttributes(stageSpan, entity);
-      stageSpan.setAttribute(
-        "backstage.catalog.processor.stage",
-        "enforcePolicy"
-      );
-      let policyEnforcedEntity;
-      try {
-        policyEnforcedEntity = await this.options.policy.enforce(entity);
-      } catch (e) {
-        throw new errors.InputError(
-          `Policy check failed for ${catalogModel.stringifyEntityRef(entity)}`,
-          e
-        );
-      }
-      if (!policyEnforcedEntity) {
-        throw new Error(
-          `Policy unexpectedly returned no data for ${catalogModel.stringifyEntityRef(
-            entity
-          )}`
-        );
-      }
-      return policyEnforcedEntity;
-    });
-  }
-  /**
-   * Validate the given entity
-   */
-  async runValidateStep(entity, context) {
-    return await withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
-      addEntityAttributes(stageSpan, entity);
-      stageSpan.setAttribute("backstage.catalog.processor.stage", "validate");
-      if (catalogModel.stringifyEntityRef(entity) !== context.entityRef) {
-        throw new errors.ConflictError(
-          "Fatal: The entity kind, namespace, or name changed during processing"
-        );
-      }
-      try {
-        validateEntity(entity);
-      } catch (e) {
-        throw new errors.ConflictError(
-          `Entity envelope for ${context.entityRef} failed validation after preprocessing`,
-          e
+    return await withActiveSpan(
+      tracer,
+      "ProcessingStage",
+      async (stageSpan) => {
+        addEntityAttributes(stageSpan, entity);
+        stageSpan.setAttribute(
+          "backstage.catalog.processor.stage",
+          "preProcess"
         );
-      }
-      let valid = false;
-      for (const processor of this.options.processors) {
-        if (processor.validateEntityKind) {
-          try {
-            const thisValid = await withActiveSpan(
+        let res = entity;
+        for (const processor of this.options.processors) {
+          if (processor.preProcessEntity) {
+            let innerRes = res;
+            res = await withActiveSpan(
               tracer,
               "ProcessingStep",
               async (span) => {
                 addEntityAttributes(span, entity);
-                addProcessorAttributes(span, "validateEntityKind", processor);
-                return await processor.validateEntityKind(entity);
-              }
-            );
-            if (thisValid) {
-              valid = true;
-              if (this.options.legacySingleProcessorValidation) {
-                break;
+                addProcessorAttributes(span, "preProcessEntity", processor);
+                try {
+                  innerRes = await processor.preProcessEntity(
+                    innerRes,
+                    context.location,
+                    context.collector.forProcessor(processor),
+                    context.originLocation,
+                    context.cache.forProcessor(processor)
+                  );
+                } catch (e) {
+                  throw new errors.InputError(
+                    `Processor ${processor.constructor.name} threw an error while preprocessing`,
+                    e
+                  );
+                }
+                return innerRes;
               }
-            }
-          } catch (e) {
-            throw new errors.InputError(
-              `Processor ${processor.constructor.name} threw an error while validating the entity ${context.entityRef}`,
-              e
             );
           }
         }
+        return res;
       }
-      if (!valid) {
-        throw new errors.InputError(
-          `No processor recognized the entity ${context.entityRef} as valid, possibly caused by a foreign kind or apiVersion`
+    );
+  }
+  /**
+   * Enforce entity policies making sure that entities conform to a general schema
+   */
+  async runPolicyStep(entity) {
+    return await withActiveSpan(
+      tracer,
+      "ProcessingStage",
+      async (stageSpan) => {
+        addEntityAttributes(stageSpan, entity);
+        stageSpan.setAttribute(
+          "backstage.catalog.processor.stage",
+          "enforcePolicy"
         );
+        let policyEnforcedEntity;
+        try {
+          policyEnforcedEntity = await this.options.policy.enforce(entity);
+        } catch (e) {
+          throw new errors.InputError(
+            `Policy check failed for ${catalogModel.stringifyEntityRef(
+              entity
+            )}`,
+            e
+          );
+        }
+        if (!policyEnforcedEntity) {
+          throw new Error(
+            `Policy unexpectedly returned no data for ${catalogModel.stringifyEntityRef(
+              entity
+            )}`
+          );
+        }
+        return policyEnforcedEntity;
       }
-    });
+    );
   }
   /**
-   * Backwards compatible processing of location entities
+   * Validate the given entity
    */
-  async runSpecialLocationStep(entity, context) {
-    return await withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
-      addEntityAttributes(stageSpan, entity);
-      stageSpan.setAttribute(
-        "backstage.catalog.processor.stage",
-        "readLocation"
-      );
-      const { type = context.location.type, presence = "required" } = entity.spec;
-      const targets = new Array();
-      if (entity.spec.target) {
-        targets.push(entity.spec.target);
-      }
-      if (entity.spec.targets) {
-        targets.push(...entity.spec.targets);
-      }
-      for (const maybeRelativeTarget of targets) {
-        if (type === "file" && maybeRelativeTarget.endsWith(path__default.default.sep)) {
-          context.collector.generic()(
-            pluginCatalogNode.processingResult.inputError(
-              context.location,
-              `LocationEntityProcessor cannot handle ${type} type location with target ${context.location.target} that ends with a path separator`
-            )
+  async runValidateStep(entity, context) {
+    return await withActiveSpan(
+      tracer,
+      "ProcessingStage",
+      async (stageSpan) => {
+        addEntityAttributes(stageSpan, entity);
+        stageSpan.setAttribute("backstage.catalog.processor.stage", "validate");
+        if (catalogModel.stringifyEntityRef(entity) !== context.entityRef) {
+          throw new errors.ConflictError(
+            "Fatal: The entity kind, namespace, or name changed during processing"
           );
-          continue;
         }
-        const target = toAbsoluteUrl(
-          this.options.integrations,
-          context.location,
-          type,
-          maybeRelativeTarget
-        );
-        let didRead = false;
+        try {
+          validateEntity(entity);
+        } catch (e) {
+          throw new errors.ConflictError(
+            `Entity envelope for ${context.entityRef} failed validation after preprocessing`,
+            e
+          );
+        }
+        let valid = false;
         for (const processor of this.options.processors) {
-          if (processor.readLocation) {
+          if (processor.validateEntityKind) {
             try {
-              const read = await withActiveSpan(
+              const thisValid = await withActiveSpan(
                 tracer,
                 "ProcessingStep",
                 async (span) => {
                   addEntityAttributes(span, entity);
-                  addProcessorAttributes(span, "readLocation", processor);
-                  return await processor.readLocation(
-                    {
-                      type,
-                      target,
-                      presence
-                    },
-                    presence === "optional",
-                    context.collector.forProcessor(processor),
-                    this.options.parser,
-                    context.cache.forProcessor(processor, target)
-                  );
+                  addProcessorAttributes(span, "validateEntityKind", processor);
+                  return await processor.validateEntityKind(entity);
                 }
               );
-              if (read) {
-                didRead = true;
-                break;
+              if (thisValid) {
+                valid = true;
+                if (this.options.legacySingleProcessorValidation) {
+                  break;
+                }
               }
             } catch (e) {
               throw new errors.InputError(
-                `Processor ${processor.constructor.name} threw an error while reading ${type}:${target}`,
+                `Processor ${processor.constructor.name} threw an error while validating the entity ${context.entityRef}`,
                 e
               );
             }
           }
         }
-        if (!didRead) {
+        if (!valid) {
           throw new errors.InputError(
-            `No processor was able to handle reading of ${type}:${target}`
+            `No processor recognized the entity ${context.entityRef} as valid, possibly caused by a foreign kind or apiVersion`
           );
         }
       }
-    });
+    );
   }
   /**
-   * Main processing step of the entity
+   * Backwards compatible processing of location entities
    */
-  async runPostProcessStep(entity, context) {
-    return await withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
-      addEntityAttributes(stageSpan, entity);
-      stageSpan.setAttribute(
-        "backstage.catalog.processor.stage",
-        "postProcessEntity"
-      );
-      let res = entity;
-      for (const processor of this.options.processors) {
-        if (processor.postProcessEntity) {
-          let innerRes = res;
-          res = await withActiveSpan(tracer, "ProcessingStep", async (span) => {
-            addEntityAttributes(span, entity);
-            addProcessorAttributes(span, "postProcessEntity", processor);
-            try {
-              innerRes = await processor.postProcessEntity(
-                innerRes,
+  async runSpecialLocationStep(entity, context) {
+    return await withActiveSpan(
+      tracer,
+      "ProcessingStage",
+      async (stageSpan) => {
+        addEntityAttributes(stageSpan, entity);
+        stageSpan.setAttribute(
+          "backstage.catalog.processor.stage",
+          "readLocation"
+        );
+        const { type = context.location.type, presence = "required" } =
+          entity.spec;
+        const targets = new Array();
+        if (entity.spec.target) {
+          targets.push(entity.spec.target);
+        }
+        if (entity.spec.targets) {
+          targets.push(...entity.spec.targets);
+        }
+        for (const maybeRelativeTarget of targets) {
+          if (
+            type === "file" &&
+            maybeRelativeTarget.endsWith(path__default.default.sep)
+          ) {
+            context.collector.generic()(
+              pluginCatalogNode.processingResult.inputError(
                 context.location,
-                context.collector.forProcessor(processor),
-                context.cache.forProcessor(processor)
-              );
-            } catch (e) {
-              throw new errors.InputError(
-                `Processor ${processor.constructor.name} threw an error while postprocessing`,
-                e
-              );
+                `LocationEntityProcessor cannot handle ${type} type location with target ${context.location.target} that ends with a path separator`
+              )
+            );
+            continue;
+          }
+          const target = toAbsoluteUrl(
+            this.options.integrations,
+            context.location,
+            type,
+            maybeRelativeTarget
+          );
+          let didRead = false;
+          for (const processor of this.options.processors) {
+            if (processor.readLocation) {
+              try {
+                const read = await withActiveSpan(
+                  tracer,
+                  "ProcessingStep",
+                  async (span) => {
+                    addEntityAttributes(span, entity);
+                    addProcessorAttributes(span, "readLocation", processor);
+                    return await processor.readLocation(
+                      {
+                        type,
+                        target,
+                        presence,
+                      },
+                      presence === "optional",
+                      context.collector.forProcessor(processor),
+                      this.options.parser,
+                      context.cache.forProcessor(processor, target)
+                    );
+                  }
+                );
+                if (read) {
+                  didRead = true;
+                  break;
+                }
+              } catch (e) {
+                throw new errors.InputError(
+                  `Processor ${processor.constructor.name} threw an error while reading ${type}:${target}`,
+                  e
+                );
+              }
             }
-            return innerRes;
-          });
+          }
+          if (!didRead) {
+            throw new errors.InputError(
+              `No processor was able to handle reading of ${type}:${target}`
+            );
+          }
         }
       }
-      return res;
-    });
+    );
+  }
+  /**
+   * Main processing step of the entity
+   */
+  async runPostProcessStep(entity, context) {
+    return await withActiveSpan(
+      tracer,
+      "ProcessingStage",
+      async (stageSpan) => {
+        addEntityAttributes(stageSpan, entity);
+        stageSpan.setAttribute(
+          "backstage.catalog.processor.stage",
+          "postProcessEntity"
+        );
+        let res = entity;
+        for (const processor of this.options.processors) {
+          if (processor.postProcessEntity) {
+            let innerRes = res;
+            res = await withActiveSpan(
+              tracer,
+              "ProcessingStep",
+              async (span) => {
+                addEntityAttributes(span, entity);
+                addProcessorAttributes(span, "postProcessEntity", processor);
+                try {
+                  innerRes = await processor.postProcessEntity(
+                    innerRes,
+                    context.location,
+                    context.collector.forProcessor(processor),
+                    context.cache.forProcessor(processor)
+                  );
+                } catch (e) {
+                  throw new errors.InputError(
+                    `Processor ${processor.constructor.name} threw an error while postprocessing`,
+                    e
+                  );
+                }
+                return innerRes;
+              }
+            );
+          }
+        }
+        return res;
+      }
+    );
   }
 }
 
@@ -3297,20 +3752,28 @@ async function getDeferredStitchableEntities(options) {
   if (["mysql", "mysql2", "pg"].includes(knex.client.config.client)) {
     itemsQuery = itemsQuery.forUpdate().skipLocked();
   }
-  const items = await itemsQuery.whereNotNull("next_stitch_at").whereNotNull("next_stitch_ticket").where("next_stitch_at", "<=", knex.fn.now()).orderBy("next_stitch_at", "asc").limit(batchSize);
+  const items = await itemsQuery
+    .whereNotNull("next_stitch_at")
+    .whereNotNull("next_stitch_ticket")
+    .where("next_stitch_at", "<=", knex.fn.now())
+    .orderBy("next_stitch_at", "asc")
+    .limit(batchSize);
   if (!items.length) {
     return [];
   }
-  await knex("refresh_state").whereIn(
-    "entity_ref",
-    items.map((i) => i.entity_ref)
-  ).whereNotNull("next_stitch_ticket").update({
-    next_stitch_at: nowPlus(knex, stitchTimeout)
-  });
+  await knex("refresh_state")
+    .whereIn(
+      "entity_ref",
+      items.map((i) => i.entity_ref)
+    )
+    .whereNotNull("next_stitch_ticket")
+    .update({
+      next_stitch_at: nowPlus(knex, stitchTimeout),
+    });
   return items.map((i) => ({
     entityRef: i.entity_ref,
     stitchTicket: i.next_stitch_ticket,
-    stitchRequestedAt: timestampToDateTime(i.next_stitch_at)
+    stitchRequestedAt: timestampToDateTime(i.next_stitch_at),
   }));
 }
 function nowPlus(knex, duration) {
@@ -3330,7 +3793,7 @@ const SPECIAL_KEYS = [
   "metadata.name",
   "metadata.namespace",
   "metadata.uid",
-  "metadata.etag"
+  "metadata.etag",
 ];
 const MAX_KEY_LENGTH = 200;
 const MAX_VALUE_LENGTH = 200;
@@ -3340,7 +3803,11 @@ function traverse(root) {
     if (SPECIAL_KEYS.includes(path)) {
       return;
     }
-    if (current === void 0 || current === null || ["string", "number", "boolean"].includes(typeof current)) {
+    if (
+      current === void 0 ||
+      current === null ||
+      ["string", "number", "boolean"].includes(typeof current)
+    ) {
       output.push({ key: path, value: current });
       return;
     }
@@ -3375,7 +3842,7 @@ function mapToRows(input, entityId) {
         entity_id: entityId,
         key,
         original_value: null,
-        value: null
+        value: null,
       });
     } else {
       const value = String(rawValue).toLocaleLowerCase("en-US");
@@ -3384,14 +3851,14 @@ function mapToRows(input, entityId) {
           entity_id: entityId,
           key,
           original_value: String(rawValue),
-          value
+          value,
         });
       } else {
         result.push({
           entity_id: entityId,
           key,
           original_value: null,
-          value: null
+          value: null,
         });
       }
     }
@@ -3405,12 +3872,15 @@ function buildEntitySearch(entityId, entity) {
   raw.push({ key: "metadata.namespace", value: entity.metadata.namespace });
   raw.push({ key: "metadata.uid", value: entity.metadata.uid });
   if (!entity.metadata.namespace) {
-    raw.push({ key: "metadata.namespace", value: catalogModel.DEFAULT_NAMESPACE });
+    raw.push({
+      key: "metadata.namespace",
+      value: catalogModel.DEFAULT_NAMESPACE,
+    });
   }
   for (const relation of (_a = entity.relations) != null ? _a : []) {
     raw.push({
       key: `relations.${relation.type}`,
-      value: relation.targetRef
+      value: relation.targetRef,
     });
   }
   const keys = new Set(raw.map((r) => r.key));
@@ -3433,50 +3903,75 @@ function buildEntitySearch(entityId, entity) {
 
 async function markDeferredStitchCompleted(option) {
   const { knex, entityRef, stitchTicket } = option;
-  await knex("refresh_state").update({
-    next_stitch_at: null,
-    next_stitch_ticket: null
-  }).where("entity_ref", "=", entityRef).andWhere("next_stitch_ticket", "=", stitchTicket);
+  await knex("refresh_state")
+    .update({
+      next_stitch_at: null,
+      next_stitch_ticket: null,
+    })
+    .where("entity_ref", "=", entityRef)
+    .andWhere("next_stitch_ticket", "=", stitchTicket);
 }
 
 const BATCH_SIZE$1 = 50;
 function generateStableHash(entity) {
-  return crypto.createHash("sha1").update(stableStringify__default.default({ ...entity })).digest("hex");
+  return crypto
+    .createHash("sha1")
+    .update(stableStringify__default.default({ ...entity }))
+    .digest("hex");
 }
 
-const scriptProtocolPattern = (
+const scriptProtocolPattern =
   // eslint-disable-next-line no-control-regex
-  /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
-);
+  /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
 async function performStitching(options) {
   var _a, _b, _c, _d;
   const { knex, logger, entityRef } = options;
   const stitchTicket = (_a = options.stitchTicket) != null ? _a : uuid.v4();
-  const entityResult = await knex("refresh_state").where({ entity_ref: entityRef }).limit(1).select("entity_id");
+  const entityResult = await knex("refresh_state")
+    .where({ entity_ref: entityRef })
+    .limit(1)
+    .select("entity_id");
   if (!entityResult.length) {
     return "abandoned";
   }
-  await knex("final_entities").insert({
-    entity_id: entityResult[0].entity_id,
-    hash: "",
-    stitch_ticket: stitchTicket
-  }).onConflict("entity_id").merge(["stitch_ticket"]);
+  await knex("final_entities")
+    .insert({
+      entity_id: entityResult[0].entity_id,
+      hash: "",
+      stitch_ticket: stitchTicket,
+    })
+    .onConflict("entity_id")
+    .merge(["stitch_ticket"]);
   const [processedResult, relationsResult] = await Promise.all([
-    knex.with("incoming_references", function incomingReferences(builder) {
-      return builder.from("refresh_state_references").where({ target_entity_ref: entityRef }).count({ count: "*" });
-    }).select({
-      entityId: "refresh_state.entity_id",
-      processedEntity: "refresh_state.processed_entity",
-      errors: "refresh_state.errors",
-      incomingReferenceCount: "incoming_references.count",
-      previousHash: "final_entities.hash"
-    }).from("refresh_state").where({ "refresh_state.entity_ref": entityRef }).crossJoin(knex.raw("incoming_references")).leftOuterJoin("final_entities", {
-      "final_entities.entity_id": "refresh_state.entity_id"
-    }),
-    knex.distinct({
-      relationType: "type",
-      relationTarget: "target_entity_ref"
-    }).from("relations").where({ source_entity_ref: entityRef }).orderBy("relationType", "asc").orderBy("relationTarget", "asc")
+    knex
+      .with("incoming_references", function incomingReferences(builder) {
+        return builder
+          .from("refresh_state_references")
+          .where({ target_entity_ref: entityRef })
+          .count({ count: "*" });
+      })
+      .select({
+        entityId: "refresh_state.entity_id",
+        processedEntity: "refresh_state.processed_entity",
+        errors: "refresh_state.errors",
+        incomingReferenceCount: "incoming_references.count",
+        previousHash: "final_entities.hash",
+      })
+      .from("refresh_state")
+      .where({ "refresh_state.entity_ref": entityRef })
+      .crossJoin(knex.raw("incoming_references"))
+      .leftOuterJoin("final_entities", {
+        "final_entities.entity_id": "refresh_state.entity_id",
+      }),
+    knex
+      .distinct({
+        relationType: "type",
+        relationTarget: "target_entity_ref",
+      })
+      .from("relations")
+      .where({ source_entity_ref: entityRef })
+      .orderBy("relationType", "asc")
+      .orderBy("relationTarget", "asc"),
   ]);
   if (!processedResult.length) {
     logger.debug(
@@ -3489,7 +3984,7 @@ async function performStitching(options) {
     processedEntity,
     errors,
     incomingReferenceCount,
-    previousHash
+    previousHash,
   } = processedResult[0];
   if (!processedEntity) {
     logger.debug(
@@ -3504,7 +3999,7 @@ async function performStitching(options) {
     logger.debug(`${entityRef} is an orphan`);
     entity.metadata.annotations = {
       ...entity.metadata.annotations,
-      ["backstage.io/orphan"]: "true"
+      ["backstage.io/orphan"]: "true",
     };
   }
   if (errors) {
@@ -3514,27 +4009,39 @@ async function performStitching(options) {
         type: catalogClient.ENTITY_STATUS_CATALOG_PROCESSING_TYPE,
         level: "error",
         message: `${e.name}: ${e.message}`,
-        error: e
+        error: e,
       }));
     }
   }
-  for (const annotation of [catalogModel.ANNOTATION_VIEW_URL, catalogModel.ANNOTATION_EDIT_URL]) {
-    const value = (_b = entity.metadata.annotations) == null ? void 0 : _b[annotation];
+  for (const annotation of [
+    catalogModel.ANNOTATION_VIEW_URL,
+    catalogModel.ANNOTATION_EDIT_URL,
+  ]) {
+    const value =
+      (_b = entity.metadata.annotations) == null ? void 0 : _b[annotation];
     if (typeof value === "string" && scriptProtocolPattern.test(value)) {
-      entity.metadata.annotations[annotation] = "https://backstage.io/annotation-rejected-for-security-reasons";
+      entity.metadata.annotations[annotation] =
+        "https://backstage.io/annotation-rejected-for-security-reasons";
     }
   }
-  entity.relations = relationsResult.filter(
-    (row) => row.relationType
-    /* exclude null row, if relevant */
-  ).map((row) => ({
-    type: row.relationType,
-    targetRef: row.relationTarget
-  }));
+  entity.relations = relationsResult
+    .filter(
+      (row) => row.relationType
+      /* exclude null row, if relevant */
+    )
+    .map((row) => ({
+      type: row.relationType,
+      targetRef: row.relationTarget,
+    }));
   if (statusItems.length) {
     entity.status = {
       ...entity.status,
-      items: [...(_d = (_c = entity.status) == null ? void 0 : _c.items) != null ? _d : [], ...statusItems]
+      items: [
+        ...((_d = (_c = entity.status) == null ? void 0 : _c.items) != null
+          ? _d
+          : []),
+        ...statusItems,
+      ],
     };
   }
   const hash = generateStableHash(entity);
@@ -3547,16 +4054,21 @@ async function performStitching(options) {
     entity.metadata.etag = hash;
   }
   const searchEntries = buildEntitySearch(entityId, entity);
-  const amountOfRowsChanged = await knex("final_entities").update({
-    final_entity: JSON.stringify(entity),
-    hash,
-    last_updated_at: knex.fn.now()
-  }).where("entity_id", entityId).where("stitch_ticket", stitchTicket).onConflict("entity_id").merge(["final_entity", "hash", "last_updated_at"]);
+  const amountOfRowsChanged = await knex("final_entities")
+    .update({
+      final_entity: JSON.stringify(entity),
+      hash,
+      last_updated_at: knex.fn.now(),
+    })
+    .where("entity_id", entityId)
+    .where("stitch_ticket", stitchTicket)
+    .onConflict("entity_id")
+    .merge(["final_entity", "hash", "last_updated_at"]);
   if (options.strategy.mode === "deferred") {
     await markDeferredStitchCompleted({
       knex,
       entityRef,
-      stitchTicket
+      stitchTicket,
     });
   }
   if (amountOfRowsChanged === 0) {
@@ -3571,20 +4083,20 @@ async function performStitching(options) {
 function progressTracker(knex, logger) {
   const promStitchedEntities = createCounterMetric({
     name: "catalog_stitched_entities_count",
-    help: "Amount of entities stitched. DEPRECATED, use OpenTelemetry metrics instead"
+    help: "Amount of entities stitched. DEPRECATED, use OpenTelemetry metrics instead",
   });
   const meter = api.metrics.getMeter("default");
   const stitchedEntities = meter.createCounter(
     "catalog.stitched.entities.count",
     {
-      description: "Amount of entities stitched"
+      description: "Amount of entities stitched",
     }
   );
   const stitchingDuration = meter.createHistogram(
     "catalog.stitching.duration",
     {
       description: "Time spent executing the full stitching flow",
-      unit: "seconds"
+      unit: "seconds",
     }
   );
   const stitchingQueueCount = meter.createObservableGauge(
@@ -3592,14 +4104,18 @@ function progressTracker(knex, logger) {
     { description: "Number of entities currently in the stitching queue" }
   );
   stitchingQueueCount.addCallback(async (result) => {
-    const total = await knex("refresh_state").count({ count: "*" }).whereNotNull("next_stitch_at").where("next_stitch_at", "<=", knex.fn.now());
+    const total = await knex("refresh_state")
+      .count({ count: "*" })
+      .whereNotNull("next_stitch_at")
+      .where("next_stitch_at", "<=", knex.fn.now());
     result.observe(Number(total[0].count));
   });
   const stitchingQueueDelay = meter.createHistogram(
     "catalog.stitching.queue.delay",
     {
-      description: "The amount of delay between being scheduled for stitching, and the start of actually being stitched",
-      unit: "seconds"
+      description:
+        "The amount of delay between being scheduled for stitching, and the start of actually being stitched",
+      unit: "seconds",
     }
   );
   function stitchStart(item) {
@@ -3629,21 +4145,28 @@ function progressTracker(knex, logger) {
     }
     return {
       markComplete,
-      markFailed
+      markFailed,
     };
   }
   return { stitchStart };
 }
 
 var __defProp$4 = Object.defineProperty;
-var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$4 = (obj, key, value) =>
+  key in obj
+    ? __defProp$4(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$4 = (obj, key, value) => {
   __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
 };
 var __accessCheck = (obj, member, msg) => {
-  if (!member.has(obj))
-    throw TypeError("Cannot " + msg);
+  if (!member.has(obj)) throw TypeError("Cannot " + msg);
 };
 var __privateAdd = (obj, member, value) => {
   if (member.has(obj))
@@ -3673,7 +4196,7 @@ const _DefaultStitcher = class _DefaultStitcher {
     return new _DefaultStitcher({
       knex: options.knex,
       logger: options.logger,
-      strategy: stitchingStrategyFromConfig(config)
+      strategy: stitchingStrategyFromConfig(config),
     });
   }
   async stitch(options) {
@@ -3683,13 +4206,15 @@ const _DefaultStitcher = class _DefaultStitcher {
         knex: this.knex,
         strategy: this.strategy,
         entityRefs,
-        entityIds
+        entityIds,
       });
       return;
     }
     if (entityRefs) {
       for (const entityRef of entityRefs) {
-        await __privateMethod(this, _stitchOne, stitchOne_fn).call(this, { entityRef });
+        await __privateMethod(this, _stitchOne, stitchOne_fn).call(this, {
+          entityRef,
+        });
       }
     }
     if (entityIds) {
@@ -3698,9 +4223,13 @@ const _DefaultStitcher = class _DefaultStitcher {
         100
       );
       for (const chunk of chunks) {
-        const rows = await this.knex("refresh_state").select("entity_ref").whereIn("entity_id", chunk);
+        const rows = await this.knex("refresh_state")
+          .select("entity_ref")
+          .whereIn("entity_id", chunk);
         for (const row of rows) {
-          await __privateMethod(this, _stitchOne, stitchOne_fn).call(this, { entityRef: row.entity_ref });
+          await __privateMethod(this, _stitchOne, stitchOne_fn).call(this, {
+            entityRef: row.entity_ref,
+          });
         }
       }
     }
@@ -3716,15 +4245,22 @@ const _DefaultStitcher = class _DefaultStitcher {
         highWatermark: 5,
         pollingIntervalMs: types.durationToMilliseconds(pollingInterval),
         loadTasks: async (count) => {
-          return await __privateMethod(this, _getStitchableEntities, getStitchableEntities_fn).call(this, count, stitchTimeout);
+          return await __privateMethod(
+            this,
+            _getStitchableEntities,
+            getStitchableEntities_fn
+          ).call(this, count, stitchTimeout);
         },
         processTask: async (item) => {
-          return await __privateMethod(this, _stitchOne, stitchOne_fn).call(this, {
-            entityRef: item.entityRef,
-            stitchTicket: item.stitchTicket,
-            stitchRequestedAt: item.stitchRequestedAt
-          });
-        }
+          return await __privateMethod(this, _stitchOne, stitchOne_fn).call(
+            this,
+            {
+              entityRef: item.entityRef,
+              stitchTicket: item.stitchTicket,
+              stitchRequestedAt: item.stitchRequestedAt,
+            }
+          );
+        },
       });
       this.stopFunc = () => {
         stopPipeline();
@@ -3741,12 +4277,12 @@ const _DefaultStitcher = class _DefaultStitcher {
   }
 };
 _getStitchableEntities = new WeakSet();
-getStitchableEntities_fn = async function(count, stitchTimeout) {
+getStitchableEntities_fn = async function (count, stitchTimeout) {
   try {
     return await getDeferredStitchableEntities({
       knex: this.knex,
       batchSize: count,
-      stitchTimeout
+      stitchTimeout,
     });
   } catch (error) {
     this.logger.warn("Failed to load stitchable entities", error);
@@ -3754,10 +4290,10 @@ getStitchableEntities_fn = async function(count, stitchTimeout) {
   }
 };
 _stitchOne = new WeakSet();
-stitchOne_fn = async function(options) {
+stitchOne_fn = async function (options) {
   const track = this.tracker.stitchStart({
     entityRef: options.entityRef,
-    stitchRequestedAt: options.stitchRequestedAt
+    stitchRequestedAt: options.stitchRequestedAt,
   });
   try {
     const result = await performStitching({
@@ -3765,7 +4301,7 @@ stitchOne_fn = async function(options) {
       logger: this.logger,
       strategy: this.strategy,
       entityRef: options.entityRef,
-      stitchTicket: options.stitchTicket
+      stitchTicket: options.stitchTicket,
     });
     track.markComplete(result);
   } catch (error) {
@@ -3776,7 +4312,7 @@ let DefaultStitcher = _DefaultStitcher;
 
 const schema = zod.z.object({
   entityRefs: zod.z.array(zod.z.string()),
-  fields: zod.z.array(zod.z.string()).optional()
+  fields: zod.z.array(zod.z.string()).optional(),
 });
 function entitiesBatchRequest(req) {
   try {
@@ -3792,7 +4328,10 @@ function basicEntityFilter(items) {
   const filtersByKey = {};
   for (const [key, value] of Object.entries(items)) {
     const values = [value].flat();
-    const f = key in filtersByKey ? filtersByKey[key] : filtersByKey[key] = { key, values: [] };
+    const f =
+      key in filtersByKey
+        ? filtersByKey[key]
+        : (filtersByKey[key] = { key, values: [] });
     f.values.push(...values);
   }
   return { anyOf: [{ allOf: Object.values(filtersByKey) }] };
@@ -3821,21 +4360,29 @@ function parseEntityFilterParams(params) {
   return { anyOf: filters.map((f) => ({ allOf: f })) };
 }
 function parseEntityFilterString(filterString) {
-  const statements = filterString.split(",").map((s) => s.trim()).filter(Boolean);
+  const statements = filterString
+    .split(",")
+    .map((s) => s.trim())
+    .filter(Boolean);
   if (!statements.length) {
     return void 0;
   }
   const filtersByKey = {};
   for (const statement of statements) {
     const equalsIndex = statement.indexOf("=");
-    const key = equalsIndex === -1 ? statement : statement.substring(0, equalsIndex).trim();
-    const value = equalsIndex === -1 ? void 0 : statement.substring(equalsIndex + 1).trim();
+    const key =
+      equalsIndex === -1
+        ? statement
+        : statement.substring(0, equalsIndex).trim();
+    const value =
+      equalsIndex === -1 ? void 0 : statement.substring(equalsIndex + 1).trim();
     if (!key) {
       throw new errors.InputError(
         `Invalid filter, '${statement}' is not a valid statement (expected a string on the form a=b or a= or a)`
       );
     }
-    const f = key in filtersByKey ? filtersByKey[key] : filtersByKey[key] = { key };
+    const f =
+      key in filtersByKey ? filtersByKey[key] : (filtersByKey[key] = { key });
     if (value !== void 0) {
       f.values = f.values || [];
       f.values.push(value);
@@ -3863,7 +4410,18 @@ function parseEntityTransformParams(params, extra) {
   const queryFields = parseStringsParam(params.fields, "fields");
   const fields = Array.from(
     new Set(
-      [...extra != null ? extra : [], ...(_a = queryFields == null ? void 0 : queryFields.map((s) => s.split(","))) != null ? _a : []].flat().map((s) => s.trim()).filter(Boolean)
+      [
+        ...(extra != null ? extra : []),
+        ...((_a =
+          queryFields == null
+            ? void 0
+            : queryFields.map((s) => s.split(","))) != null
+          ? _a
+          : []),
+      ]
+        .flat()
+        .map((s) => s.trim())
+        .filter(Boolean)
     )
   );
   if (!fields.length) {
@@ -3895,7 +4453,9 @@ function parseEntityOrderFieldParams(params) {
   return orderFieldStrings.map((orderFieldString) => {
     const [field, order] = orderFieldString.split(",");
     if (order !== void 0 && !isOrder(order)) {
-      throw new errors.InputError("Invalid order field order, must be asc or desc");
+      throw new errors.InputError(
+        "Invalid order field order, must be asc or desc"
+      );
     }
     return { field, order };
   });
@@ -3910,7 +4470,7 @@ function parseQueryEntitiesParams(params) {
     const decodedCursor = decodeCursor(params.cursor);
     const response2 = {
       cursor: decodedCursor,
-      fields
+      fields,
     };
     return response2;
   }
@@ -3922,8 +4482,8 @@ function parseQueryEntitiesParams(params) {
     orderFields,
     fullTextFilter: {
       term: params.fullTextFilterTerm || "",
-      fields: params.fullTextFilterFields
-    }
+      fields: params.fullTextFilterFields,
+    },
   };
   return response;
 }
@@ -3941,18 +4501,20 @@ function parseEntityFacetParams(params) {
 
 function parseEntityOrderParams(params) {
   var _a;
-  return (_a = parseStringsParam(params.order, "order")) == null ? void 0 : _a.map((item) => {
-    const match = item.match(/^(asc|desc):(.+)$/);
-    if (!match) {
-      throw new errors.InputError(
-        `Invalid order parameter "${item}", expected "<asc or desc>:<field name>"`
-      );
-    }
-    return {
-      order: match[1],
-      field: match[2]
-    };
-  });
+  return (_a = parseStringsParam(params.order, "order")) == null
+    ? void 0
+    : _a.map((item) => {
+        const match = item.match(/^(asc|desc):(.+)$/);
+        if (!match) {
+          throw new errors.InputError(
+            `Invalid order parameter "${item}", expected "<asc or desc>:<field name>"`
+          );
+        }
+        return {
+          order: match[1],
+          field: match[2],
+        };
+      });
 }
 
 const spec = {
@@ -3960,17 +4522,18 @@ const spec = {
   info: {
     title: "catalog",
     version: "1",
-    description: "The Backstage backend plugin that provides the Backstage catalog",
+    description:
+      "The Backstage backend plugin that provides the Backstage catalog",
     license: {
       name: "Apache-2.0",
-      url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+      url: "http://www.apache.org/licenses/LICENSE-2.0.html",
     },
-    contact: {}
+    contact: {},
   },
   servers: [
     {
-      url: "/"
-    }
+      url: "/",
+    },
   ],
   components: {
     examples: {},
@@ -3982,8 +4545,8 @@ const spec = {
         required: true,
         allowReserved: true,
         schema: {
-          type: "string"
-        }
+          type: "string",
+        },
       },
       namespace: {
         name: "namespace",
@@ -3991,8 +4554,8 @@ const spec = {
         required: true,
         allowReserved: true,
         schema: {
-          type: "string"
-        }
+          type: "string",
+        },
       },
       name: {
         name: "name",
@@ -4000,8 +4563,8 @@ const spec = {
         required: true,
         allowReserved: true,
         schema: {
-          type: "string"
-        }
+          type: "string",
+        },
       },
       uid: {
         name: "uid",
@@ -4009,8 +4572,8 @@ const spec = {
         required: true,
         allowReserved: true,
         schema: {
-          type: "string"
-        }
+          type: "string",
+        },
       },
       cursor: {
         name: "cursor",
@@ -4020,8 +4583,8 @@ const spec = {
         allowReserved: true,
         schema: {
           type: "string",
-          minLength: 1
-        }
+          minLength: 1,
+        },
       },
       after: {
         name: "after",
@@ -4031,8 +4594,8 @@ const spec = {
         allowReserved: true,
         schema: {
           type: "string",
-          minLength: 1
-        }
+          minLength: 1,
+        },
       },
       fields: {
         name: "fields",
@@ -4044,17 +4607,17 @@ const spec = {
         schema: {
           type: "array",
           items: {
-            type: "string"
-          }
+            type: "string",
+          },
         },
         examples: {
           "Get name and the entire relations collection": {
-            value: ["metadata.name", "relations"]
+            value: ["metadata.name", "relations"],
           },
           "Get kind, name and namespace": {
-            value: ["kind", "metadata.name", "metadata.namespace"]
-          }
-        }
+            value: ["kind", "metadata.name", "metadata.namespace"],
+          },
+        },
       },
       filter: {
         name: "filter",
@@ -4065,19 +4628,19 @@ const spec = {
         schema: {
           type: "array",
           items: {
-            type: "string"
-          }
+            type: "string",
+          },
         },
         examples: {
           "Get groups": {
-            value: ["kind=group"]
+            value: ["kind=group"],
           },
           "Get orphaned components": {
             value: [
-              "kind=component,metadata.annotations.backstage.io/orphan=true"
-            ]
-          }
-        }
+              "kind=component,metadata.annotations.backstage.io/orphan=true",
+            ],
+          },
+        },
       },
       offset: {
         name: "offset",
@@ -4087,8 +4650,8 @@ const spec = {
         allowReserved: true,
         schema: {
           type: "integer",
-          minimum: 0
-        }
+          minimum: 0,
+        },
       },
       limit: {
         name: "limit",
@@ -4098,8 +4661,8 @@ const spec = {
         allowReserved: true,
         schema: {
           type: "integer",
-          minimum: 0
-        }
+          minimum: 0,
+        },
       },
       orderField: {
         name: "orderField",
@@ -4111,20 +4674,20 @@ const spec = {
           type: "array",
           items: {
             type: "string",
-            description: "A two-item tuple of [field, order]."
-          }
+            description: "A two-item tuple of [field, order].",
+          },
         },
         explode: true,
         style: "form",
         examples: {
           "Order ascending by name": {
-            value: ["metadata.name,asc"]
+            value: ["metadata.name,asc"],
           },
           "Order descending by owner": {
-            value: ["spec.owner,desc"]
-          }
-        }
-      }
+            value: ["spec.owner,desc"],
+          },
+        },
+      },
     },
     requestBodies: {},
     responses: {
@@ -4133,11 +4696,11 @@ const spec = {
         content: {
           "application/json": {
             schema: {
-              $ref: "#/components/schemas/Error"
-            }
-          }
-        }
-      }
+              $ref: "#/components/schemas/Error",
+            },
+          },
+        },
+      },
     },
     schemas: {
       Error: {
@@ -4147,82 +4710,85 @@ const spec = {
             type: "object",
             properties: {
               name: {
-                type: "string"
+                type: "string",
               },
               message: {
-                type: "string"
+                type: "string",
               },
               stack: {
-                type: "string"
+                type: "string",
               },
               code: {
-                type: "string"
-              }
+                type: "string",
+              },
             },
-            required: ["name", "message"]
+            required: ["name", "message"],
           },
           request: {
             type: "object",
             properties: {
               method: {
-                type: "string"
+                type: "string",
               },
               url: {
-                type: "string"
-              }
+                type: "string",
+              },
             },
-            required: ["method", "url"]
+            required: ["method", "url"],
           },
           response: {
             type: "object",
             properties: {
               statusCode: {
-                type: "number"
-              }
+                type: "number",
+              },
             },
-            required: ["statusCode"]
-          }
+            required: ["statusCode"],
+          },
         },
         required: ["error", "response"],
-        additionalProperties: {}
+        additionalProperties: {},
       },
       JsonObject: {
         type: "object",
         properties: {},
         description: "A type representing all allowed JSON object values.",
-        additionalProperties: {}
+        additionalProperties: {},
       },
       MapStringString: {
         type: "object",
         properties: {},
         additionalProperties: {
-          type: "string"
+          type: "string",
         },
-        description: "Construct a type with a set of properties K of type T"
+        description: "Construct a type with a set of properties K of type T",
       },
       EntityLink: {
         type: "object",
         properties: {
           type: {
             type: "string",
-            description: "An optional value to categorize links into specific groups"
+            description:
+              "An optional value to categorize links into specific groups",
           },
           icon: {
             type: "string",
-            description: "An optional semantic key that represents a visual icon."
+            description:
+              "An optional semantic key that represents a visual icon.",
           },
           title: {
             type: "string",
-            description: "An optional descriptive title for the link."
+            description: "An optional descriptive title for the link.",
           },
           url: {
             type: "string",
-            description: "The url to the external site, document, etc."
-          }
+            description: "The url to the external site, document, etc.",
+          },
         },
         required: ["url"],
-        description: "A link to external information that is related to the entity.",
-        additionalProperties: false
+        description:
+          "A link to external information that is related to the entity.",
+        additionalProperties: false,
       },
       EntityMeta: {
         type: "object",
@@ -4230,67 +4796,74 @@ const spec = {
           links: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/EntityLink"
+              $ref: "#/components/schemas/EntityLink",
             },
-            description: "A list of external hyperlinks related to the entity."
+            description: "A list of external hyperlinks related to the entity.",
           },
           tags: {
             type: "array",
             items: {
-              type: "string"
+              type: "string",
             },
-            description: "A list of single-valued strings, to for example classify catalog entities in\nvarious ways."
+            description:
+              "A list of single-valued strings, to for example classify catalog entities in\nvarious ways.",
           },
           annotations: {
-            $ref: "#/components/schemas/MapStringString"
+            $ref: "#/components/schemas/MapStringString",
           },
           labels: {
-            $ref: "#/components/schemas/MapStringString"
+            $ref: "#/components/schemas/MapStringString",
           },
           description: {
             type: "string",
-            description: "A short (typically relatively few words, on one line) description of the\nentity."
+            description:
+              "A short (typically relatively few words, on one line) description of the\nentity.",
           },
           title: {
             type: "string",
-            description: "A display name of the entity, to be presented in user interfaces instead\nof the `name` property above, when available.\nThis field is sometimes useful when the `name` is cumbersome or ends up\nbeing perceived as overly technical. The title generally does not have\nas stringent format requirements on it, so it may contain special\ncharacters and be more explanatory. Do keep it very short though, and\navoid situations where a title can be confused with the name of another\nentity, or where two entities share a title.\nNote that this is only for display purposes, and may be ignored by some\nparts of the code. Entity references still always make use of the `name`\nproperty, not the title."
+            description:
+              "A display name of the entity, to be presented in user interfaces instead\nof the `name` property above, when available.\nThis field is sometimes useful when the `name` is cumbersome or ends up\nbeing perceived as overly technical. The title generally does not have\nas stringent format requirements on it, so it may contain special\ncharacters and be more explanatory. Do keep it very short though, and\navoid situations where a title can be confused with the name of another\nentity, or where two entities share a title.\nNote that this is only for display purposes, and may be ignored by some\nparts of the code. Entity references still always make use of the `name`\nproperty, not the title.",
           },
           namespace: {
             type: "string",
-            description: "The namespace that the entity belongs to."
+            description: "The namespace that the entity belongs to.",
           },
           name: {
             type: "string",
-            description: "The name of the entity.\nMust be unique within the catalog at any given point in time, for any\ngiven namespace + kind pair. This value is part of the technical\nidentifier of the entity, and as such it will appear in URLs, database\ntables, entity references, and similar. It is subject to restrictions\nregarding what characters are allowed.\nIf you want to use a different, more human readable string with fewer\nrestrictions on it in user interfaces, see the `title` field below."
+            description:
+              "The name of the entity.\nMust be unique within the catalog at any given point in time, for any\ngiven namespace + kind pair. This value is part of the technical\nidentifier of the entity, and as such it will appear in URLs, database\ntables, entity references, and similar. It is subject to restrictions\nregarding what characters are allowed.\nIf you want to use a different, more human readable string with fewer\nrestrictions on it in user interfaces, see the `title` field below.",
           },
           etag: {
             type: "string",
-            description: "An opaque string that changes for each update operation to any part of\nthe entity, including metadata.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, and the server will then reject the\noperation if it does not match the current stored value."
+            description:
+              "An opaque string that changes for each update operation to any part of\nthe entity, including metadata.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, and the server will then reject the\noperation if it does not match the current stored value.",
           },
           uid: {
             type: "string",
-            description: "A globally unique ID for the entity.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, but the server is free to reject requests\nthat do so in such a way that it breaks semantics."
-          }
+            description:
+              "A globally unique ID for the entity.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, but the server is free to reject requests\nthat do so in such a way that it breaks semantics.",
+          },
         },
         required: ["name"],
         description: "Metadata fields common to all versions/kinds of entity.",
-        additionalProperties: {}
+        additionalProperties: {},
       },
       EntityRelation: {
         type: "object",
         properties: {
           targetRef: {
             type: "string",
-            description: "The entity ref of the target of this relation."
+            description: "The entity ref of the target of this relation.",
           },
           type: {
             type: "string",
-            description: "The type of the relation."
-          }
+            description: "The type of the relation.",
+          },
         },
         required: ["targetRef", "type"],
-        description: "A relation of a specific type to another entity in the catalog.",
-        additionalProperties: false
+        description:
+          "A relation of a specific type to another entity in the catalog.",
+        additionalProperties: false,
       },
       Entity: {
         type: "object",
@@ -4298,27 +4871,30 @@ const spec = {
           relations: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/EntityRelation"
+              $ref: "#/components/schemas/EntityRelation",
             },
-            description: "The relations that this entity has with other entities."
+            description:
+              "The relations that this entity has with other entities.",
           },
           spec: {
-            $ref: "#/components/schemas/JsonObject"
+            $ref: "#/components/schemas/JsonObject",
           },
           metadata: {
-            $ref: "#/components/schemas/EntityMeta"
+            $ref: "#/components/schemas/EntityMeta",
           },
           kind: {
             type: "string",
-            description: "The high level entity type being described."
+            description: "The high level entity type being described.",
           },
           apiVersion: {
             type: "string",
-            description: "The version of specification format for this particular entity that\nthis is written against."
-          }
+            description:
+              "The version of specification format for this particular entity that\nthis is written against.",
+          },
         },
         required: ["metadata", "kind", "apiVersion"],
-        description: "The parts of the format that's common to all versions/kinds of entity."
+        description:
+          "The parts of the format that's common to all versions/kinds of entity.",
       },
       NullableEntity: {
         type: "object",
@@ -4326,28 +4902,31 @@ const spec = {
           relations: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/EntityRelation"
+              $ref: "#/components/schemas/EntityRelation",
             },
-            description: "The relations that this entity has with other entities."
+            description:
+              "The relations that this entity has with other entities.",
           },
           spec: {
-            $ref: "#/components/schemas/JsonObject"
+            $ref: "#/components/schemas/JsonObject",
           },
           metadata: {
-            $ref: "#/components/schemas/EntityMeta"
+            $ref: "#/components/schemas/EntityMeta",
           },
           kind: {
             type: "string",
-            description: "The high level entity type being described."
+            description: "The high level entity type being described.",
           },
           apiVersion: {
             type: "string",
-            description: "The version of specification format for this particular entity that\nthis is written against."
-          }
+            description:
+              "The version of specification format for this particular entity that\nthis is written against.",
+          },
         },
         required: ["metadata", "kind", "apiVersion"],
-        description: "The parts of the format that's common to all versions/kinds of entity.",
-        nullable: true
+        description:
+          "The parts of the format that's common to all versions/kinds of entity.",
+        nullable: true,
       },
       EntityAncestryResponse: {
         type: "object",
@@ -4359,23 +4938,23 @@ const spec = {
               properties: {
                 parentEntityRefs: {
                   items: {
-                    type: "string"
+                    type: "string",
                   },
-                  type: "array"
+                  type: "array",
                 },
                 entity: {
-                  $ref: "#/components/schemas/Entity"
-                }
+                  $ref: "#/components/schemas/Entity",
+                },
               },
-              required: ["parentEntityRefs", "entity"]
-            }
+              required: ["parentEntityRefs", "entity"],
+            },
           },
           rootEntityRef: {
-            type: "string"
-          }
+            type: "string",
+          },
         },
         required: ["items", "rootEntityRef"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       EntitiesBatchResponse: {
         type: "object",
@@ -4383,26 +4962,27 @@ const spec = {
           items: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/NullableEntity"
+              $ref: "#/components/schemas/NullableEntity",
             },
-            description: "The list of entities, in the same order as the refs in the request. Entries\nthat are null signify that no entity existed with that ref."
-          }
+            description:
+              "The list of entities, in the same order as the refs in the request. Entries\nthat are null signify that no entity existed with that ref.",
+          },
         },
         required: ["items"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       EntityFacet: {
         type: "object",
         properties: {
           value: {
-            type: "string"
+            type: "string",
           },
           count: {
-            type: "number"
-          }
+            type: "number",
+          },
         },
         required: ["value", "count"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       EntityFacetsResponse: {
         type: "object",
@@ -4412,81 +4992,83 @@ const spec = {
             additionalProperties: {
               type: "array",
               items: {
-                $ref: "#/components/schemas/EntityFacet"
-              }
-            }
-          }
+                $ref: "#/components/schemas/EntityFacet",
+              },
+            },
+          },
         },
         required: ["facets"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       Location: {
         type: "object",
         properties: {
           target: {
-            type: "string"
+            type: "string",
           },
           type: {
-            type: "string"
+            type: "string",
           },
           id: {
-            type: "string"
-          }
+            type: "string",
+          },
         },
         required: ["target", "type", "id"],
         description: "Entity location for a specific entity.",
-        additionalProperties: false
+        additionalProperties: false,
       },
       LocationSpec: {
         type: "object",
         properties: {
           target: {
-            type: "string"
+            type: "string",
           },
           type: {
-            type: "string"
-          }
+            type: "string",
+          },
         },
         required: ["target", "type"],
         description: "Holds the entity location information.",
-        additionalProperties: false
+        additionalProperties: false,
       },
       AnalyzeLocationExistingEntity: {
         type: "object",
         properties: {
           entity: {
-            $ref: "#/components/schemas/Entity"
+            $ref: "#/components/schemas/Entity",
           },
           isRegistered: {
-            type: "boolean"
+            type: "boolean",
           },
           location: {
-            $ref: "#/components/schemas/LocationSpec"
-          }
+            $ref: "#/components/schemas/LocationSpec",
+          },
         },
         required: ["entity", "isRegistered", "location"],
-        description: "If the folder pointed to already contained catalog info yaml files, they are\nread and emitted like this so that the frontend can inform the user that it\nlocated them and can make sure to register them as well if they weren't\nalready",
-        additionalProperties: false
+        description:
+          "If the folder pointed to already contained catalog info yaml files, they are\nread and emitted like this so that the frontend can inform the user that it\nlocated them and can make sure to register them as well if they weren't\nalready",
+        additionalProperties: false,
       },
       RecursivePartialEntityRelation: {
         type: "object",
         properties: {
           targetRef: {
             type: "string",
-            description: "The entity ref of the target of this relation."
+            description: "The entity ref of the target of this relation.",
           },
           type: {
             type: "string",
-            description: "The type of the relation."
-          }
+            description: "The type of the relation.",
+          },
         },
-        description: "A relation of a specific type to another entity in the catalog.",
-        additionalProperties: false
+        description:
+          "A relation of a specific type to another entity in the catalog.",
+        additionalProperties: false,
       },
       RecursivePartialEntityMeta: {
         allOf: [
           {
-            $ref: "#/components/schemas/JsonObject"
+            $ref: "#/components/schemas/JsonObject",
           },
           {
             type: "object",
@@ -4494,108 +5076,121 @@ const spec = {
               links: {
                 type: "array",
                 items: {
-                  $ref: "#/components/schemas/EntityLink"
+                  $ref: "#/components/schemas/EntityLink",
                 },
-                description: "A list of external hyperlinks related to the entity."
+                description:
+                  "A list of external hyperlinks related to the entity.",
               },
               tags: {
                 type: "array",
                 items: {
-                  type: "string"
+                  type: "string",
                 },
-                description: "A list of single-valued strings, to for example classify catalog entities in\nvarious ways."
+                description:
+                  "A list of single-valued strings, to for example classify catalog entities in\nvarious ways.",
               },
               annotations: {
-                $ref: "#/components/schemas/MapStringString"
+                $ref: "#/components/schemas/MapStringString",
               },
               labels: {
-                $ref: "#/components/schemas/MapStringString"
+                $ref: "#/components/schemas/MapStringString",
               },
               description: {
                 type: "string",
-                description: "A short (typically relatively few words, on one line) description of the\nentity."
+                description:
+                  "A short (typically relatively few words, on one line) description of the\nentity.",
               },
               title: {
                 type: "string",
-                description: "A display name of the entity, to be presented in user interfaces instead\nof the `name` property above, when available.\nThis field is sometimes useful when the `name` is cumbersome or ends up\nbeing perceived as overly technical. The title generally does not have\nas stringent format requirements on it, so it may contain special\ncharacters and be more explanatory. Do keep it very short though, and\navoid situations where a title can be confused with the name of another\nentity, or where two entities share a title.\nNote that this is only for display purposes, and may be ignored by some\nparts of the code. Entity references still always make use of the `name`\nproperty, not the title."
+                description:
+                  "A display name of the entity, to be presented in user interfaces instead\nof the `name` property above, when available.\nThis field is sometimes useful when the `name` is cumbersome or ends up\nbeing perceived as overly technical. The title generally does not have\nas stringent format requirements on it, so it may contain special\ncharacters and be more explanatory. Do keep it very short though, and\navoid situations where a title can be confused with the name of another\nentity, or where two entities share a title.\nNote that this is only for display purposes, and may be ignored by some\nparts of the code. Entity references still always make use of the `name`\nproperty, not the title.",
               },
               namespace: {
                 type: "string",
-                description: "The namespace that the entity belongs to."
+                description: "The namespace that the entity belongs to.",
               },
               name: {
                 type: "string",
-                description: "The name of the entity.\nMust be unique within the catalog at any given point in time, for any\ngiven namespace + kind pair. This value is part of the technical\nidentifier of the entity, and as such it will appear in URLs, database\ntables, entity references, and similar. It is subject to restrictions\nregarding what characters are allowed.\nIf you want to use a different, more human readable string with fewer\nrestrictions on it in user interfaces, see the `title` field below."
+                description:
+                  "The name of the entity.\nMust be unique within the catalog at any given point in time, for any\ngiven namespace + kind pair. This value is part of the technical\nidentifier of the entity, and as such it will appear in URLs, database\ntables, entity references, and similar. It is subject to restrictions\nregarding what characters are allowed.\nIf you want to use a different, more human readable string with fewer\nrestrictions on it in user interfaces, see the `title` field below.",
               },
               etag: {
                 type: "string",
-                description: "An opaque string that changes for each update operation to any part of\nthe entity, including metadata.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, and the server will then reject the\noperation if it does not match the current stored value."
+                description:
+                  "An opaque string that changes for each update operation to any part of\nthe entity, including metadata.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, and the server will then reject the\noperation if it does not match the current stored value.",
               },
               uid: {
                 type: "string",
-                description: "A globally unique ID for the entity.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, but the server is free to reject requests\nthat do so in such a way that it breaks semantics."
-              }
+                description:
+                  "A globally unique ID for the entity.\nThis field can not be set by the user at creation time, and the server\nwill reject an attempt to do so. The field will be populated in read\noperations. The field can (optionally) be specified when performing\nupdate or delete operations, but the server is free to reject requests\nthat do so in such a way that it breaks semantics.",
+              },
             },
-            description: "Metadata fields common to all versions/kinds of entity."
-          }
+            description:
+              "Metadata fields common to all versions/kinds of entity.",
+          },
         ],
-        additionalProperties: false
+        additionalProperties: false,
       },
       RecursivePartialEntity: {
         type: "object",
         properties: {
           apiVersion: {
             type: "string",
-            description: "The version of specification format for this particular entity that\nthis is written against."
+            description:
+              "The version of specification format for this particular entity that\nthis is written against.",
           },
           kind: {
             type: "string",
-            description: "The high level entity type being described."
+            description: "The high level entity type being described.",
           },
           metadata: {
-            $ref: "#/components/schemas/RecursivePartialEntityMeta"
+            $ref: "#/components/schemas/RecursivePartialEntityMeta",
           },
           spec: {
-            $ref: "#/components/schemas/JsonObject"
+            $ref: "#/components/schemas/JsonObject",
           },
           relations: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/RecursivePartialEntityRelation"
+              $ref: "#/components/schemas/RecursivePartialEntityRelation",
             },
-            description: "The relations that this entity has with other entities."
-          }
+            description:
+              "The relations that this entity has with other entities.",
+          },
         },
         description: "Makes all keys of an entire hierarchy optional.",
-        additionalProperties: false
+        additionalProperties: false,
       },
       AnalyzeLocationEntityField: {
         type: "object",
         properties: {
           description: {
             type: "string",
-            description: 'A text to show to the user to inform about the choices made. Like, it could say\n"Found a CODEOWNERS file that covers this target, so we suggest leaving this\nfield empty; which would currently make it owned by X" where X is taken from the\ncodeowners file.'
+            description:
+              'A text to show to the user to inform about the choices made. Like, it could say\n"Found a CODEOWNERS file that covers this target, so we suggest leaving this\nfield empty; which would currently make it owned by X" where X is taken from the\ncodeowners file.',
           },
           value: {
             type: "string",
-            nullable: true
+            nullable: true,
           },
           state: {
             type: "string",
             enum: [
               "analysisSuggestedValue",
               "analysisSuggestedNoValue",
-              "needsUserInput"
+              "needsUserInput",
             ],
-            description: "The outcome of the analysis for this particular field"
+            description:
+              "The outcome of the analysis for this particular field",
           },
           field: {
             type: "string",
-            description: 'e.g. "spec.owner"? The frontend needs to know how to "inject" the field into the\nentity again if the user wants to change it'
-          }
+            description:
+              'e.g. "spec.owner"? The frontend needs to know how to "inject" the field into the\nentity again if the user wants to change it',
+          },
         },
         required: ["description", "value", "state", "field"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       AnalyzeLocationGenerateEntity: {
         type: "object",
@@ -4603,48 +5198,49 @@ const spec = {
           fields: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/AnalyzeLocationEntityField"
-            }
+              $ref: "#/components/schemas/AnalyzeLocationEntityField",
+            },
           },
           entity: {
-            $ref: "#/components/schemas/RecursivePartialEntity"
-          }
+            $ref: "#/components/schemas/RecursivePartialEntity",
+          },
         },
         required: ["fields", "entity"],
-        description: "This is some form of representation of what the analyzer could deduce.\nWe should probably have a chat about how this can best be conveyed to\nthe frontend. It'll probably contain a (possibly incomplete) entity, plus\nenough info for the frontend to know what form data to show to the user\nfor overriding/completing the info.",
-        additionalProperties: false
+        description:
+          "This is some form of representation of what the analyzer could deduce.\nWe should probably have a chat about how this can best be conveyed to\nthe frontend. It'll probably contain a (possibly incomplete) entity, plus\nenough info for the frontend to know what form data to show to the user\nfor overriding/completing the info.",
+        additionalProperties: false,
       },
       AnalyzeLocationResponse: {
         type: "object",
         properties: {
           generateEntities: {
             items: {
-              $ref: "#/components/schemas/AnalyzeLocationGenerateEntity"
+              $ref: "#/components/schemas/AnalyzeLocationGenerateEntity",
             },
-            type: "array"
+            type: "array",
           },
           existingEntityFiles: {
             items: {
-              $ref: "#/components/schemas/AnalyzeLocationExistingEntity"
+              $ref: "#/components/schemas/AnalyzeLocationExistingEntity",
             },
-            type: "array"
-          }
+            type: "array",
+          },
         },
         required: ["generateEntities", "existingEntityFiles"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       LocationInput: {
         type: "object",
         properties: {
           type: {
-            type: "string"
+            type: "string",
           },
           target: {
-            type: "string"
-          }
+            type: "string",
+          },
         },
         required: ["type", "target"],
-        additionalProperties: false
+        additionalProperties: false,
       },
       EntitiesQueryResponse: {
         type: "object",
@@ -4652,38 +5248,38 @@ const spec = {
           items: {
             type: "array",
             items: {
-              $ref: "#/components/schemas/Entity"
+              $ref: "#/components/schemas/Entity",
             },
-            description: "The list of entities paginated by a specific filter."
+            description: "The list of entities paginated by a specific filter.",
           },
           totalItems: {
-            type: "number"
+            type: "number",
           },
           pageInfo: {
             type: "object",
             properties: {
               nextCursor: {
                 type: "string",
-                description: "The cursor for the next batch of entities."
+                description: "The cursor for the next batch of entities.",
               },
               prevCursor: {
                 type: "string",
-                description: "The cursor for the previous batch of entities."
-              }
-            }
-          }
+                description: "The cursor for the previous batch of entities.",
+              },
+            },
+          },
         },
         required: ["items", "totalItems", "pageInfo"],
-        additionalProperties: false
-      }
+        additionalProperties: false,
+      },
     },
     securitySchemes: {
       JWT: {
         type: "http",
         scheme: "bearer",
-        bearerFormat: "JWT"
-      }
-    }
+        bearerFormat: "JWT",
+      },
+    },
   },
   paths: {
     "/refresh": {
@@ -4691,21 +5287,21 @@ const spec = {
         operationId: "RefreshEntity",
         description: "Refresh the entity related to entityRef.",
         responses: {
-          "200": {
-            description: "Refreshed"
+          200: {
+            description: "Refreshed",
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [],
         requestBody: {
@@ -4716,68 +5312,70 @@ const spec = {
                 type: "object",
                 properties: {
                   authorizationToken: {
-                    type: "string"
+                    type: "string",
                   },
                   entityRef: {
                     type: "string",
-                    description: "The reference to a single entity that should be refreshed"
-                  }
+                    description:
+                      "The reference to a single entity that should be refreshed",
+                  },
                 },
                 required: ["entityRef"],
-                description: "Options for requesting a refresh of entities in the catalog.",
-                additionalProperties: false
-              }
-            }
-          }
-        }
-      }
+                description:
+                  "Options for requesting a refresh of entities in the catalog.",
+                additionalProperties: false,
+              },
+            },
+          },
+        },
+      },
     },
     "/entities": {
       get: {
         operationId: "GetEntities",
         description: "Get all entities matching a given filter.",
         responses: {
-          "200": {
+          200: {
             description: "",
             content: {
               "application/json": {
                 schema: {
                   type: "array",
                   items: {
-                    $ref: "#/components/schemas/Entity"
-                  }
-                }
-              }
-            }
+                    $ref: "#/components/schemas/Entity",
+                  },
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
-            $ref: "#/components/parameters/fields"
+            $ref: "#/components/parameters/fields",
           },
           {
-            $ref: "#/components/parameters/limit"
+            $ref: "#/components/parameters/limit",
           },
           {
-            $ref: "#/components/parameters/filter"
+            $ref: "#/components/parameters/filter",
           },
           {
-            $ref: "#/components/parameters/offset"
+            $ref: "#/components/parameters/offset",
           },
           {
-            $ref: "#/components/parameters/after"
+            $ref: "#/components/parameters/after",
           },
           {
             name: "order",
@@ -4787,183 +5385,184 @@ const spec = {
             schema: {
               type: "array",
               items: {
-                type: "string"
-              }
-            }
-          }
-        ]
-      }
+                type: "string",
+              },
+            },
+          },
+        ],
+      },
     },
     "/entities/by-uid/{uid}": {
       get: {
         operationId: "GetEntityByUid",
         description: "Get a single entity by the UID.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/Entity"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/Entity",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
-            $ref: "#/components/parameters/uid"
-          }
-        ]
+            $ref: "#/components/parameters/uid",
+          },
+        ],
       },
       delete: {
         operationId: "DeleteEntityByUid",
         description: "Delete a single entity by UID.",
         responses: {
-          "204": {
-            description: "Deleted successfully."
+          204: {
+            description: "Deleted successfully.",
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
-            $ref: "#/components/parameters/uid"
-          }
-        ]
-      }
+            $ref: "#/components/parameters/uid",
+          },
+        ],
+      },
     },
     "/entities/by-name/{kind}/{namespace}/{name}": {
       get: {
         operationId: "GetEntityByName",
         description: "Get an entity by an entity ref.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/Entity"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/Entity",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
-            $ref: "#/components/parameters/kind"
+            $ref: "#/components/parameters/kind",
           },
           {
-            $ref: "#/components/parameters/namespace"
+            $ref: "#/components/parameters/namespace",
           },
           {
-            $ref: "#/components/parameters/name"
-          }
-        ]
-      }
+            $ref: "#/components/parameters/name",
+          },
+        ],
+      },
     },
     "/entities/by-name/{kind}/{namespace}/{name}/ancestry": {
       get: {
         operationId: "GetEntityAncestryByName",
         description: "Get an entity's ancestry by entity ref.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/EntityAncestryResponse"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/EntityAncestryResponse",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
-            $ref: "#/components/parameters/kind"
+            $ref: "#/components/parameters/kind",
           },
           {
-            $ref: "#/components/parameters/namespace"
+            $ref: "#/components/parameters/namespace",
           },
           {
-            $ref: "#/components/parameters/name"
-          }
-        ]
-      }
+            $ref: "#/components/parameters/name",
+          },
+        ],
+      },
     },
     "/entities/by-refs": {
       post: {
         operationId: "GetEntitiesByRefs",
-        description: "Get a batch set of entities given an array of entityRefs.",
+        description:
+          "Get a batch set of entities given an array of entityRefs.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/EntitiesBatchResponse"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/EntitiesBatchResponse",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         requestBody: {
           required: false,
@@ -4976,86 +5575,86 @@ const spec = {
                   entityRefs: {
                     type: "array",
                     items: {
-                      type: "string"
-                    }
+                      type: "string",
+                    },
                   },
                   fields: {
                     type: "array",
                     items: {
-                      type: "string"
-                    }
-                  }
-                }
+                      type: "string",
+                    },
+                  },
+                },
               },
               examples: {
                 "Fetch Backstage entities": {
                   value: {
                     entityRefs: [
                       "component:default/backstage",
-                      "api:default/backstage"
-                    ]
-                  }
+                      "api:default/backstage",
+                    ],
+                  },
                 },
                 "Fetch annotations for backstage entity": {
                   value: {
                     entityRefs: ["component:default/backstage"],
-                    fields: ["metadata.annotations"]
-                  }
-                }
-              }
-            }
-          }
+                    fields: ["metadata.annotations"],
+                  },
+                },
+              },
+            },
+          },
         },
         parameters: [
           {
-            $ref: "#/components/parameters/filter"
-          }
-        ]
-      }
+            $ref: "#/components/parameters/filter",
+          },
+        ],
+      },
     },
     "/entities/by-query": {
       get: {
         operationId: "GetEntitiesByQuery",
         description: "Search for entities by a given query.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/EntitiesQueryResponse"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/EntitiesQueryResponse",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
-            $ref: "#/components/parameters/fields"
+            $ref: "#/components/parameters/fields",
           },
           {
-            $ref: "#/components/parameters/limit"
+            $ref: "#/components/parameters/limit",
           },
           {
-            $ref: "#/components/parameters/orderField"
+            $ref: "#/components/parameters/orderField",
           },
           {
-            $ref: "#/components/parameters/cursor"
+            $ref: "#/components/parameters/cursor",
           },
           {
-            $ref: "#/components/parameters/filter"
+            $ref: "#/components/parameters/filter",
           },
           {
             name: "fullTextFilterTerm",
@@ -5064,54 +5663,55 @@ const spec = {
             required: false,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
+              type: "string",
+            },
           },
           {
             name: "fullTextFilterFields",
             in: "query",
-            description: "A comma separated list of fields to sort returned results by.",
+            description:
+              "A comma separated list of fields to sort returned results by.",
             required: false,
             allowReserved: true,
             schema: {
               type: "array",
               items: {
-                type: "string"
-              }
+                type: "string",
+              },
             },
             explode: false,
-            style: "form"
-          }
-        ]
-      }
+            style: "form",
+          },
+        ],
+      },
     },
     "/entity-facets": {
       get: {
         operationId: "GetEntityFacets",
         description: "Get all entity facets that match the given filters.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/EntityFacetsResponse"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/EntityFacetsResponse",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
@@ -5122,30 +5722,30 @@ const spec = {
             schema: {
               type: "array",
               items: {
-                type: "string"
-              }
+                type: "string",
+              },
             },
             examples: {
               "Entities by kind": {
-                value: ["kind"]
+                value: ["kind"],
               },
               "Entities by spec type": {
-                value: ["spec.type"]
-              }
-            }
+                value: ["spec.type"],
+              },
+            },
           },
           {
-            $ref: "#/components/parameters/filter"
-          }
-        ]
-      }
+            $ref: "#/components/parameters/filter",
+          },
+        ],
+      },
     },
     "/locations": {
       post: {
         operationId: "CreateLocation",
         description: "Create a location for a given target.",
         responses: {
-          "201": {
+          201: {
             description: "Created",
             content: {
               "application/json": {
@@ -5153,35 +5753,35 @@ const spec = {
                   type: "object",
                   properties: {
                     exists: {
-                      type: "boolean"
+                      type: "boolean",
                     },
                     entities: {
                       items: {
-                        $ref: "#/components/schemas/Entity"
+                        $ref: "#/components/schemas/Entity",
                       },
-                      type: "array"
+                      type: "array",
                     },
                     location: {
-                      $ref: "#/components/schemas/Location"
-                    }
+                      $ref: "#/components/schemas/Location",
+                    },
                   },
-                  required: ["entities", "location"]
-                }
-              }
-            }
+                  required: ["entities", "location"],
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
@@ -5190,9 +5790,9 @@ const spec = {
             required: false,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
-          }
+              type: "string",
+            },
+          },
         ],
         requestBody: {
           required: true,
@@ -5202,23 +5802,23 @@ const spec = {
                 type: "object",
                 properties: {
                   target: {
-                    type: "string"
+                    type: "string",
                   },
                   type: {
-                    type: "string"
-                  }
+                    type: "string",
+                  },
                 },
-                required: ["target", "type"]
-              }
-            }
-          }
-        }
+                required: ["target", "type"],
+              },
+            },
+          },
+        },
       },
       get: {
         operationId: "GetLocations",
         description: "Get all locations",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
@@ -5228,52 +5828,52 @@ const spec = {
                     type: "object",
                     properties: {
                       data: {
-                        $ref: "#/components/schemas/Location"
-                      }
+                        $ref: "#/components/schemas/Location",
+                      },
                     },
-                    required: ["data"]
-                  }
-                }
-              }
-            }
+                    required: ["data"],
+                  },
+                },
+              },
+            },
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
-        parameters: []
-      }
+        parameters: [],
+      },
     },
     "/locations/{id}": {
       get: {
         operationId: "GetLocation",
         description: "Get a location by id.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/Location"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/Location",
+                },
+              },
+            },
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
@@ -5282,30 +5882,30 @@ const spec = {
             required: true,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
-          }
-        ]
+              type: "string",
+            },
+          },
+        ],
       },
       delete: {
         operationId: "DeleteLocation",
         description: "Delete a location by id.",
         responses: {
-          "204": {
-            description: "No content"
+          204: {
+            description: "No content",
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
@@ -5314,36 +5914,36 @@ const spec = {
             required: true,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
-          }
-        ]
-      }
+              type: "string",
+            },
+          },
+        ],
+      },
     },
     "/locations/by-entity/{kind}/{namespace}/{name}": {
       get: {
         operationId: "getLocationByEntity",
         description: "Get a location for entity.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/Location"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/Location",
+                },
+              },
+            },
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [
           {
@@ -5352,8 +5952,8 @@ const spec = {
             required: true,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
+              type: "string",
+            },
           },
           {
             in: "path",
@@ -5361,8 +5961,8 @@ const spec = {
             required: true,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
+              type: "string",
+            },
           },
           {
             in: "path",
@@ -5370,39 +5970,39 @@ const spec = {
             required: true,
             allowReserved: true,
             schema: {
-              type: "string"
-            }
-          }
-        ]
-      }
+              type: "string",
+            },
+          },
+        ],
+      },
     },
     "/analyze-location": {
       post: {
         operationId: "AnalyzeLocation",
         description: "Validate a given location.",
         responses: {
-          "200": {
+          200: {
             description: "Ok",
             content: {
               "application/json": {
                 schema: {
-                  $ref: "#/components/schemas/AnalyzeLocationResponse"
-                }
-              }
-            }
+                  $ref: "#/components/schemas/AnalyzeLocationResponse",
+                },
+              },
+            },
           },
-          "400": {
-            $ref: "#/components/responses/ErrorResponse"
+          400: {
+            $ref: "#/components/responses/ErrorResponse",
           },
           default: {
-            $ref: "#/components/responses/ErrorResponse"
-          }
+            $ref: "#/components/responses/ErrorResponse",
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [],
         requestBody: {
@@ -5413,28 +6013,29 @@ const spec = {
                 type: "object",
                 properties: {
                   catalogFileName: {
-                    type: "string"
+                    type: "string",
                   },
                   location: {
-                    $ref: "#/components/schemas/LocationInput"
-                  }
+                    $ref: "#/components/schemas/LocationInput",
+                  },
                 },
-                required: ["location"]
-              }
-            }
-          }
-        }
-      }
+                required: ["location"],
+              },
+            },
+          },
+        },
+      },
     },
     "/validate-entity": {
       post: {
         operationId: "ValidateEntity",
-        description: "Validate that a passed in entity has no errors in schema.",
+        description:
+          "Validate that a passed in entity has no errors in schema.",
         responses: {
-          "200": {
-            description: "Ok"
+          200: {
+            description: "Ok",
           },
-          "400": {
+          400: {
             description: "Validation errors.",
             content: {
               "application/json": {
@@ -5447,28 +6048,28 @@ const spec = {
                         type: "object",
                         properties: {
                           name: {
-                            type: "string"
+                            type: "string",
                           },
                           message: {
-                            type: "string"
-                          }
+                            type: "string",
+                          },
                         },
                         required: ["name", "message"],
-                        additionalProperties: {}
-                      }
-                    }
+                        additionalProperties: {},
+                      },
+                    },
                   },
-                  required: ["errors"]
-                }
-              }
-            }
-          }
+                  required: ["errors"],
+                },
+              },
+            },
+          },
         },
         security: [
           {},
           {
-            JWT: []
-          }
+            JWT: [],
+          },
         ],
         parameters: [],
         requestBody: {
@@ -5479,29 +6080,26 @@ const spec = {
                 type: "object",
                 properties: {
                   location: {
-                    type: "string"
+                    type: "string",
                   },
                   entity: {
                     type: "object",
-                    additionalProperties: {}
-                  }
+                    additionalProperties: {},
+                  },
                 },
-                required: ["location", "entity"]
-              }
-            }
-          }
-        }
-      }
-    }
-  }
+                required: ["location", "entity"],
+              },
+            },
+          },
+        },
+      },
+    },
+  },
 };
-const createOpenApiRouter = async (options) => backendOpenapiUtils.createValidatedOpenApiRouter(spec, options);
+const createOpenApiRouter = async (options) =>
+  backendOpenapiUtils.createValidatedOpenApiRouter(spec, options);
 
-function parseEntityPaginationParams({
-  limit,
-  offset,
-  after
-}) {
+function parseEntityPaginationParams({ limit, offset, after }) {
   if (offset === void 0 && limit === void 0 && after === void 0) {
     return void 0;
   }
@@ -5515,9 +6113,9 @@ function parseEntityPaginationParams({
     throw new errors.InputError(`Invalid after, must not be empty`);
   }
   return {
-    ...offset !== void 0 ? { offset } : {},
-    ...limit !== void 0 ? { limit } : {},
-    ...after !== void 0 ? { after } : {}
+    ...(offset !== void 0 ? { offset } : {}),
+    ...(limit !== void 0 ? { limit } : {}),
+    ...(after !== void 0 ? { after } : {}),
   };
 }
 
@@ -5526,8 +6124,8 @@ async function createRouter(options) {
     validatorOptions: {
       // We want the spec to be up to date with the expected value, but the return type needs
       //  to be controlled by the router implementation not the request validator.
-      ignorePaths: /^\/validate-entity\/?$/
-    }
+      ignorePaths: /^\/validate-entity\/?$/,
+    },
   });
   const {
     entitiesCatalog,
@@ -5539,19 +6137,22 @@ async function createRouter(options) {
     logger,
     permissionIntegrationRouter,
     auth,
-    httpAuth
+    httpAuth,
   } = options;
-  const readonlyEnabled = config.getOptionalBoolean("catalog.readonly") || false;
+  const readonlyEnabled =
+    config.getOptionalBoolean("catalog.readonly") || false;
   if (readonlyEnabled) {
     logger.info("Catalog is running in readonly mode");
   }
   if (refreshService) {
     router.post("/refresh", async (req, res) => {
       const { authorizationToken, ...restBody } = req.body;
-      const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
+      const credentials = authorizationToken
+        ? await auth.authenticate(authorizationToken)
+        : await httpAuth.credentials(req);
       await refreshService.refresh({
         ...restBody,
-        credentials
+        credentials,
       });
       res.status(200).end();
     });
@@ -5560,136 +6161,156 @@ async function createRouter(options) {
     router.use(permissionIntegrationRouter);
   }
   if (entitiesCatalog) {
-    router.get("/entities", async (req, res) => {
-      const { entities, pageInfo } = await entitiesCatalog.entities({
-        filter: parseEntityFilterParams(req.query),
-        fields: parseEntityTransformParams(req.query),
-        order: parseEntityOrderParams(req.query),
-        pagination: parseEntityPaginationParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      if (pageInfo.hasNextPage) {
-        const url = new URL(`http://ignored${req.url}`);
-        url.searchParams.delete("offset");
-        url.searchParams.set("after", pageInfo.endCursor);
-        res.setHeader("link", `<${url.pathname}${url.search}>; rel="next"`);
-      }
-      res.json(entities);
-    }).get("/entities/by-query", async (req, res) => {
-      const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
-        limit: req.query.limit,
-        ...parseQueryEntitiesParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      res.json({
-        items,
-        totalItems,
-        pageInfo: {
-          ...pageInfo.nextCursor && {
-            nextCursor: encodeCursor(pageInfo.nextCursor)
+    router
+      .get("/entities", async (req, res) => {
+        const { entities, pageInfo } = await entitiesCatalog.entities({
+          filter: parseEntityFilterParams(req.query),
+          fields: parseEntityTransformParams(req.query),
+          order: parseEntityOrderParams(req.query),
+          pagination: parseEntityPaginationParams(req.query),
+          credentials: await httpAuth.credentials(req),
+        });
+        if (pageInfo.hasNextPage) {
+          const url = new URL(`http://ignored${req.url}`);
+          url.searchParams.delete("offset");
+          url.searchParams.set("after", pageInfo.endCursor);
+          res.setHeader("link", `<${url.pathname}${url.search}>; rel="next"`);
+        }
+        res.json(entities);
+      })
+      .get("/entities/by-query", async (req, res) => {
+        const { items, pageInfo, totalItems } =
+          await entitiesCatalog.queryEntities({
+            limit: req.query.limit,
+            ...parseQueryEntitiesParams(req.query),
+            credentials: await httpAuth.credentials(req),
+          });
+        res.json({
+          items,
+          totalItems,
+          pageInfo: {
+            ...(pageInfo.nextCursor && {
+              nextCursor: encodeCursor(pageInfo.nextCursor),
+            }),
+            ...(pageInfo.prevCursor && {
+              prevCursor: encodeCursor(pageInfo.prevCursor),
+            }),
           },
-          ...pageInfo.prevCursor && {
-            prevCursor: encodeCursor(pageInfo.prevCursor)
-          }
+        });
+      })
+      .get("/entities/by-uid/:uid", async (req, res) => {
+        const { uid } = req.params;
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter({ "metadata.uid": uid }),
+          credentials: await httpAuth.credentials(req),
+        });
+        if (!entities.length) {
+          throw new errors.NotFoundError(`No entity with uid ${uid}`);
         }
-      });
-    }).get("/entities/by-uid/:uid", async (req, res) => {
-      const { uid } = req.params;
-      const { entities } = await entitiesCatalog.entities({
-        filter: basicEntityFilter({ "metadata.uid": uid }),
-        credentials: await httpAuth.credentials(req)
-      });
-      if (!entities.length) {
-        throw new errors.NotFoundError(`No entity with uid ${uid}`);
-      }
-      res.status(200).json(entities[0]);
-    }).delete("/entities/by-uid/:uid", async (req, res) => {
-      const { uid } = req.params;
-      await entitiesCatalog.removeEntityByUid(uid, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(204).end();
-    }).get("/entities/by-name/:kind/:namespace/:name", async (req, res) => {
-      const { kind, namespace, name } = req.params;
-      const { entities } = await entitiesCatalog.entities({
-        filter: basicEntityFilter({
-          kind,
-          "metadata.namespace": namespace,
-          "metadata.name": name
-        }),
-        credentials: await httpAuth.credentials(req)
-      });
-      if (!entities.length) {
-        throw new errors.NotFoundError(
-          `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
-        );
-      }
-      res.status(200).json(entities[0]);
-    }).get(
-      "/entities/by-name/:kind/:namespace/:name/ancestry",
-      async (req, res) => {
+        res.status(200).json(entities[0]);
+      })
+      .delete("/entities/by-uid/:uid", async (req, res) => {
+        const { uid } = req.params;
+        await entitiesCatalog.removeEntityByUid(uid, {
+          credentials: await httpAuth.credentials(req),
+        });
+        res.status(204).end();
+      })
+      .get("/entities/by-name/:kind/:namespace/:name", async (req, res) => {
         const { kind, namespace, name } = req.params;
-        const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
-        const response = await entitiesCatalog.entityAncestry(entityRef, {
-          credentials: await httpAuth.credentials(req)
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter({
+            kind,
+            "metadata.namespace": namespace,
+            "metadata.name": name,
+          }),
+          credentials: await httpAuth.credentials(req),
+        });
+        if (!entities.length) {
+          throw new errors.NotFoundError(
+            `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
+          );
+        }
+        res.status(200).json(entities[0]);
+      })
+      .get(
+        "/entities/by-name/:kind/:namespace/:name/ancestry",
+        async (req, res) => {
+          const { kind, namespace, name } = req.params;
+          const entityRef = catalogModel.stringifyEntityRef({
+            kind,
+            namespace,
+            name,
+          });
+          const response = await entitiesCatalog.entityAncestry(entityRef, {
+            credentials: await httpAuth.credentials(req),
+          });
+          res.status(200).json(response);
+        }
+      )
+      .post("/entities/by-refs", async (req, res) => {
+        const request = entitiesBatchRequest(req);
+        const response = await entitiesCatalog.entitiesBatch({
+          entityRefs: request.entityRefs,
+          filter: parseEntityFilterParams(req.query),
+          fields: parseEntityTransformParams(req.query, request.fields),
+          credentials: await httpAuth.credentials(req),
+        });
+        res.status(200).json(response);
+      })
+      .get("/entity-facets", async (req, res) => {
+        const response = await entitiesCatalog.facets({
+          filter: parseEntityFilterParams(req.query),
+          facets: parseEntityFacetParams(req.query),
+          credentials: await httpAuth.credentials(req),
         });
         res.status(200).json(response);
-      }
-    ).post("/entities/by-refs", async (req, res) => {
-      const request = entitiesBatchRequest(req);
-      const response = await entitiesCatalog.entitiesBatch({
-        entityRefs: request.entityRefs,
-        filter: parseEntityFilterParams(req.query),
-        fields: parseEntityTransformParams(req.query, request.fields),
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(response);
-    }).get("/entity-facets", async (req, res) => {
-      const response = await entitiesCatalog.facets({
-        filter: parseEntityFilterParams(req.query),
-        facets: parseEntityFacetParams(req.query),
-        credentials: await httpAuth.credentials(req)
       });
-      res.status(200).json(response);
-    });
   }
   if (locationService) {
-    router.post("/locations", async (req, res) => {
-      const location = await validateRequestBody(req, locationInput);
-      const dryRun = yn__default.default(req.query.dryRun, { default: false });
-      if (!dryRun) {
+    router
+      .post("/locations", async (req, res) => {
+        const location = await validateRequestBody(req, locationInput);
+        const dryRun = yn__default.default(req.query.dryRun, {
+          default: false,
+        });
+        if (!dryRun) {
+          disallowReadonlyMode(readonlyEnabled);
+        }
+        const output = await locationService.createLocation(location, dryRun, {
+          credentials: await httpAuth.credentials(req),
+        });
+        res.status(201).json(output);
+      })
+      .get("/locations", async (req, res) => {
+        const locations = await locationService.listLocations({
+          credentials: await httpAuth.credentials(req),
+        });
+        res.status(200).json(locations.map((l) => ({ data: l })));
+      })
+      .get("/locations/:id", async (req, res) => {
+        const { id } = req.params;
+        const output = await locationService.getLocation(id, {
+          credentials: await httpAuth.credentials(req),
+        });
+        res.status(200).json(output);
+      })
+      .delete("/locations/:id", async (req, res) => {
         disallowReadonlyMode(readonlyEnabled);
-      }
-      const output = await locationService.createLocation(location, dryRun, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(201).json(output);
-    }).get("/locations", async (req, res) => {
-      const locations = await locationService.listLocations({
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(locations.map((l) => ({ data: l })));
-    }).get("/locations/:id", async (req, res) => {
-      const { id } = req.params;
-      const output = await locationService.getLocation(id, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(output);
-    }).delete("/locations/:id", async (req, res) => {
-      disallowReadonlyMode(readonlyEnabled);
-      const { id } = req.params;
-      await locationService.deleteLocation(id, {
-        credentials: await httpAuth.credentials(req)
+        const { id } = req.params;
+        await locationService.deleteLocation(id, {
+          credentials: await httpAuth.credentials(req),
+        });
+        res.status(204).end();
+      })
+      .get("/locations/by-entity/:kind/:namespace/:name", async (req, res) => {
+        const { kind, namespace, name } = req.params;
+        const output = await locationService.getLocationByEntity(
+          { kind, namespace, name },
+          { credentials: await httpAuth.credentials(req) }
+        );
+        res.status(200).json(output);
       });
-      res.status(204).end();
-    }).get("/locations/by-entity/:kind/:namespace/:name", async (req, res) => {
-      const { kind, namespace, name } = req.params;
-      const output = await locationService.getLocationByEntity(
-        { kind, namespace, name },
-        { credentials: await httpAuth.credentials(req) }
-      );
-      res.status(200).json(output);
-    });
   }
   if (locationAnalyzer) {
     router.post("/analyze-location", async (req, res) => {
@@ -5697,12 +6318,12 @@ async function createRouter(options) {
         req,
         zod.z.object({
           location: locationInput,
-          catalogFilename: zod.z.string().optional()
+          catalogFilename: zod.z.string().optional(),
         })
       );
       const schema = zod.z.object({
         location: locationInput,
-        catalogFilename: zod.z.string().optional()
+        catalogFilename: zod.z.string().optional(),
       });
       const parsedBody = schema.parse(body);
       try {
@@ -5711,7 +6332,8 @@ async function createRouter(options) {
       } catch (err) {
         if (
           // Catch errors from parse-url library.
-          err.name === "Error" && "subject_url" in err
+          err.name === "Error" &&
+          "subject_url" in err
         ) {
           throw new errors.InputError("The given location.target is not a URL");
         }
@@ -5723,7 +6345,7 @@ async function createRouter(options) {
     router.post("/validate-entity", async (req, res) => {
       const bodySchema = zod.z.object({
         entity: zod.z.unknown(),
-        location: zod.z.string()
+        location: zod.z.string(),
       });
       let body;
       let entity;
@@ -5738,7 +6360,7 @@ async function createRouter(options) {
           );
       } catch (err) {
         return res.status(400).json({
-          errors: [errors.serializeError(err)]
+          errors: [errors.serializeError(err)],
         });
       }
       const processingResult = await orchestrator.process({
@@ -5749,14 +6371,14 @@ async function createRouter(options) {
             annotations: {
               [catalogModel.ANNOTATION_LOCATION]: body.location,
               [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
-              ...entity.metadata.annotations
-            }
-          }
-        }
+              ...entity.metadata.annotations,
+            },
+          },
+        },
       });
       if (!processingResult.ok)
         res.status(400).json({
-          errors: processingResult.errors.map((e) => errors.serializeError(e))
+          errors: processingResult.errors.map((e) => errors.serializeError(e)),
         });
       return res.status(200).end();
     });
@@ -5766,9 +6388,17 @@ async function createRouter(options) {
 }
 
 var __defProp$3 = Object.defineProperty;
-var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$3 = (obj, key, value) =>
+  key in obj
+    ? __defProp$3(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$3 = (obj, key, value) => {
-  __defNormalProp$3(obj, key + "" , value);
+  __defNormalProp$3(obj, key + "", value);
   return value;
 };
 class DefaultRefreshService {
@@ -5779,18 +6409,18 @@ class DefaultRefreshService {
   async refresh(options) {
     await this.database.transaction(async (tx) => {
       const { entityRefs } = await this.database.listAncestors(tx, {
-        entityRef: options.entityRef
+        entityRef: options.entityRef,
       });
-      const locationAncestor = entityRefs.find(
-        (ref) => ref.startsWith("location:")
+      const locationAncestor = entityRefs.find((ref) =>
+        ref.startsWith("location:")
       );
       if (locationAncestor) {
         await this.database.refresh(tx, {
-          entityRef: locationAncestor
+          entityRef: locationAncestor,
         });
       }
       await this.database.refresh(tx, {
-        entityRef: options.entityRef
+        entityRef: options.entityRef,
       });
     });
   }
@@ -5802,16 +6432,20 @@ class AuthorizedRefreshService {
     this.permissionApi = permissionApi;
   }
   async refresh(options) {
-    const authorizeDecision = (await this.permissionApi.authorize(
-      [
-        {
-          permission: alpha.catalogEntityRefreshPermission,
-          resourceRef: options.entityRef
-        }
-      ],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizeDecision.result !== pluginPermissionCommon.AuthorizeResult.ALLOW) {
+    const authorizeDecision = (
+      await this.permissionApi.authorize(
+        [
+          {
+            permission: alpha.catalogEntityRefreshPermission,
+            resourceRef: options.entityRef,
+          },
+        ],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizeDecision.result !== pluginPermissionCommon.AuthorizeResult.ALLOW
+    ) {
       throw new errors.NotAllowedError();
     }
     await this.service.refresh(options);
@@ -5819,9 +6453,17 @@ class AuthorizedRefreshService {
 }
 
 var __defProp$2 = Object.defineProperty;
-var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$2 = (obj, key, value) =>
+  key in obj
+    ? __defProp$2(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$2 = (obj, key, value) => {
-  __defNormalProp$2(obj, key + "" , value);
+  __defNormalProp$2(obj, key + "", value);
   return value;
 };
 const _DefaultCatalogRulesEnforcer = class _DefaultCatalogRulesEnforcer {
@@ -5869,41 +6511,48 @@ const _DefaultCatalogRulesEnforcer = class _DefaultCatalogRulesEnforcer {
   static fromConfig(config) {
     const rules = new Array();
     if (config.has("catalog.rules")) {
-      const globalRules = config.getConfigArray("catalog.rules").map((ruleConf) => {
-        var _a;
-        return {
-          allow: ruleConf.getStringArray("allow").map((kind) => ({ kind })),
-          locations: (_a = ruleConf.getOptionalConfigArray("locations")) == null ? void 0 : _a.map((locationConfig) => {
-            const location = {
-              pattern: locationConfig.getOptionalString("pattern"),
-              type: locationConfig.getString("type"),
-              exact: locationConfig.getOptionalString("exact")
-            };
-            if (location.pattern && location.exact) {
-              throw new Error(
-                "A catalog rule location cannot have both exact and pattern values"
-              );
-            }
-            return location;
-          })
-        };
-      });
+      const globalRules = config
+        .getConfigArray("catalog.rules")
+        .map((ruleConf) => {
+          var _a;
+          return {
+            allow: ruleConf.getStringArray("allow").map((kind) => ({ kind })),
+            locations:
+              (_a = ruleConf.getOptionalConfigArray("locations")) == null
+                ? void 0
+                : _a.map((locationConfig) => {
+                    const location = {
+                      pattern: locationConfig.getOptionalString("pattern"),
+                      type: locationConfig.getString("type"),
+                      exact: locationConfig.getOptionalString("exact"),
+                    };
+                    if (location.pattern && location.exact) {
+                      throw new Error(
+                        "A catalog rule location cannot have both exact and pattern values"
+                      );
+                    }
+                    return location;
+                  }),
+          };
+        });
       rules.push(...globalRules);
     } else {
       rules.push(..._DefaultCatalogRulesEnforcer.defaultRules);
     }
     if (config.has("catalog.locations")) {
-      const locationRules = config.getConfigArray("catalog.locations").flatMap((locConf) => {
-        if (!locConf.has("rules")) {
-          return [];
-        }
-        const type = locConf.getString("type");
-        const exact = resolveTarget(type, locConf.getString("target"));
-        return locConf.getConfigArray("rules").map((ruleConf) => ({
-          allow: ruleConf.getStringArray("allow").map((kind) => ({ kind })),
-          locations: [{ type, exact }]
-        }));
-      });
+      const locationRules = config
+        .getConfigArray("catalog.locations")
+        .flatMap((locConf) => {
+          if (!locConf.has("rules")) {
+            return [];
+          }
+          const type = locConf.getString("type");
+          const exact = resolveTarget(type, locConf.getString("target"));
+          return locConf.getConfigArray("rules").map((ruleConf) => ({
+            allow: ruleConf.getStringArray("allow").map((kind) => ({ kind })),
+            locations: [{ type, exact }],
+          }));
+        });
       rules.push(...locationRules);
     }
     return new _DefaultCatalogRulesEnforcer(rules);
@@ -5931,13 +6580,23 @@ const _DefaultCatalogRulesEnforcer = class _DefaultCatalogRulesEnforcer {
       if (matcher.type !== (location == null ? void 0 : location.type)) {
         continue;
       }
-      if (matcher.exact && matcher.exact !== (location == null ? void 0 : location.target)) {
+      if (
+        matcher.exact &&
+        matcher.exact !== (location == null ? void 0 : location.target)
+      ) {
         continue;
       }
-      if (matcher.pattern && !minimatch.minimatch(location == null ? void 0 : location.target, matcher.pattern, {
-        nocase: true,
-        dot: true
-      })) {
+      if (
+        matcher.pattern &&
+        !minimatch.minimatch(
+          location == null ? void 0 : location.target,
+          matcher.pattern,
+          {
+            nocase: true,
+            dot: true,
+          }
+        )
+      ) {
         continue;
       }
       return true;
@@ -5950,7 +6609,11 @@ const _DefaultCatalogRulesEnforcer = class _DefaultCatalogRulesEnforcer {
       return true;
     }
     for (const matcher of matchers) {
-      if (((_a = entity == null ? void 0 : entity.kind) == null ? void 0 : _a.toLowerCase()) !== matcher.kind.toLowerCase()) {
+      if (
+        ((_a = entity == null ? void 0 : entity.kind) == null
+          ? void 0
+          : _a.toLowerCase()) !== matcher.kind.toLowerCase()
+      ) {
         continue;
       }
       return true;
@@ -5965,8 +6628,8 @@ const _DefaultCatalogRulesEnforcer = class _DefaultCatalogRulesEnforcer {
  */
 __publicField$2(_DefaultCatalogRulesEnforcer, "defaultRules", [
   {
-    allow: ["Component", "API", "Location"].map((kind) => ({ kind }))
-  }
+    allow: ["Component", "API", "Location"].map((kind) => ({ kind })),
+  },
 ]);
 let DefaultCatalogRulesEnforcer = _DefaultCatalogRulesEnforcer;
 function resolveTarget(type, target) {
@@ -5977,15 +6640,27 @@ function resolveTarget(type, target) {
 }
 
 var __defProp$1 = Object.defineProperty;
-var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp$1 = (obj, key, value) =>
+  key in obj
+    ? __defProp$1(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField$1 = (obj, key, value) => {
-  __defNormalProp$1(obj, key + "" , value);
+  __defNormalProp$1(obj, key + "", value);
   return value;
 };
 class Connection {
   constructor(config) {
     this.config = config;
-    __publicField$1(this, "validateEntityEnvelope", catalogModel.entityEnvelopeSchemaValidator());
+    __publicField$1(
+      this,
+      "validateEntityEnvelope",
+      catalogModel.entityEnvelopeSchemaValidator()
+    );
   }
   async applyMutation(mutation) {
     const db = this.config.providerDatabase;
@@ -5995,25 +6670,29 @@ class Connection {
         await db.replaceUnprocessedEntities(tx, {
           sourceKey: this.config.id,
           type: "full",
-          items: mutation.entities
+          items: mutation.entities,
         });
       });
     } else if (mutation.type === "delta") {
       this.check(mutation.added.map((e) => e.entity));
       this.check(
-        mutation.removed.map((e) => "entity" in e ? e.entity : void 0).filter((e) => Boolean(e))
+        mutation.removed
+          .map((e) => ("entity" in e ? e.entity : void 0))
+          .filter((e) => Boolean(e))
       );
       await db.transaction(async (tx) => {
         await db.replaceUnprocessedEntities(tx, {
           sourceKey: this.config.id,
           type: "delta",
           added: mutation.added,
-          removed: mutation.removed.map(
-            (r) => "entityRef" in r ? r : {
-              entityRef: catalogModel.stringifyEntityRef(r.entity),
-              locationKey: r.locationKey
-            }
-          )
+          removed: mutation.removed.map((r) =>
+            "entityRef" in r
+              ? r
+              : {
+                  entityRef: catalogModel.stringifyEntityRef(r.entity),
+                  locationKey: r.locationKey,
+                }
+          ),
         });
       });
     }
@@ -6022,7 +6701,7 @@ class Connection {
     const db = this.config.providerDatabase;
     await db.transaction(async (tx) => {
       return db.refreshByRefreshKeys(tx, {
-        keys: options.keys
+        keys: options.keys,
       });
     });
   }
@@ -6041,14 +6720,15 @@ async function connectEntityProviders(db, providers) {
     providers.map(async (provider) => {
       const connection = new Connection({
         id: provider.getProviderName(),
-        providerDatabase: db
+        providerDatabase: db,
       });
       return provider.connect(connection);
     })
   );
 }
 
-const createCatalogPermissionRule = pluginPermissionNode.makeCreatePermissionRule();
+const createCatalogPermissionRule =
+  pluginPermissionNode.makeCreatePermissionRule();
 
 const hasAnnotation = createCatalogPermissionRule({
   name: "HAS_ANNOTATION",
@@ -6056,18 +6736,33 @@ const hasAnnotation = createCatalogPermissionRule({
   resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
   paramsSchema: zod.z.object({
     annotation: zod.z.string().describe("Name of the annotation to match on"),
-    value: zod.z.string().optional().describe("Value of the annotation to match on")
+    value: zod.z
+      .string()
+      .optional()
+      .describe("Value of the annotation to match on"),
   }),
   apply: (resource, { annotation, value }) => {
     var _a, _b;
-    return !!((_a = resource.metadata.annotations) == null ? void 0 : _a.hasOwnProperty(annotation)) && (value === void 0 ? true : ((_b = resource.metadata.annotations) == null ? void 0 : _b[annotation]) === value);
+    return (
+      !!((_a = resource.metadata.annotations) == null
+        ? void 0
+        : _a.hasOwnProperty(annotation)) &&
+      (value === void 0
+        ? true
+        : ((_b = resource.metadata.annotations) == null
+            ? void 0
+            : _b[annotation]) === value)
+    );
   },
-  toQuery: ({ annotation, value }) => value === void 0 ? {
-    key: `metadata.annotations.${annotation}`
-  } : {
-    key: `metadata.annotations.${annotation}`,
-    values: [value]
-  }
+  toQuery: ({ annotation, value }) =>
+    value === void 0
+      ? {
+          key: `metadata.annotations.${annotation}`,
+        }
+      : {
+          key: `metadata.annotations.${annotation}`,
+          values: [value],
+        },
 });
 
 const isEntityKind = createCatalogPermissionRule({
@@ -6075,18 +6770,22 @@ const isEntityKind = createCatalogPermissionRule({
   description: "Allow entities matching a specified kind",
   resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
   paramsSchema: zod.z.object({
-    kinds: zod.z.array(zod.z.string()).describe("List of kinds to match at least one of")
+    kinds: zod.z
+      .array(zod.z.string())
+      .describe("List of kinds to match at least one of"),
   }),
   apply(resource, { kinds }) {
     const resourceKind = resource.kind.toLocaleLowerCase("en-US");
-    return kinds.some((kind) => kind.toLocaleLowerCase("en-US") === resourceKind);
+    return kinds.some(
+      (kind) => kind.toLocaleLowerCase("en-US") === resourceKind
+    );
   },
   toQuery({ kinds }) {
     return {
       key: "kind",
-      values: kinds.map((kind) => kind.toLocaleLowerCase("en-US"))
+      values: kinds.map((kind) => kind.toLocaleLowerCase("en-US")),
     };
-  }
+  },
 });
 
 const isEntityOwner = createCatalogPermissionRule({
@@ -6094,20 +6793,24 @@ const isEntityOwner = createCatalogPermissionRule({
   description: "Allow entities owned by a specified claim",
   resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
   paramsSchema: zod.z.object({
-    claims: zod.z.array(zod.z.string()).describe(
-      `List of claims to match at least one on within ${catalogModel.RELATION_OWNED_BY}`
-    )
+    claims: zod.z
+      .array(zod.z.string())
+      .describe(
+        `List of claims to match at least one on within ${catalogModel.RELATION_OWNED_BY}`
+      ),
   }),
   apply: (resource, { claims }) => {
     if (!resource.relations) {
       return false;
     }
-    return resource.relations.filter((relation) => relation.type === catalogModel.RELATION_OWNED_BY).some((relation) => claims.includes(relation.targetRef));
+    return resource.relations
+      .filter((relation) => relation.type === catalogModel.RELATION_OWNED_BY)
+      .some((relation) => claims.includes(relation.targetRef));
   },
   toQuery: ({ claims }) => ({
     key: "relations.ownedBy",
-    values: claims
-  })
+    values: claims,
+  }),
 });
 
 const hasLabel = createCatalogPermissionRule({
@@ -6115,43 +6818,51 @@ const hasLabel = createCatalogPermissionRule({
   description: "Allow entities with the specified label",
   resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
   paramsSchema: zod.z.object({
-    label: zod.z.string().describe("Name of the label to match on")
+    label: zod.z.string().describe("Name of the label to match on"),
   }),
   apply: (resource, { label }) => {
     var _a;
-    return !!((_a = resource.metadata.labels) == null ? void 0 : _a.hasOwnProperty(label));
+    return !!((_a = resource.metadata.labels) == null
+      ? void 0
+      : _a.hasOwnProperty(label));
   },
   toQuery: ({ label }) => ({
-    key: `metadata.labels.${label}`
-  })
+    key: `metadata.labels.${label}`,
+  }),
 });
 
-const createPropertyRule = (propertyType) => createCatalogPermissionRule({
-  name: `HAS_${propertyType.toUpperCase()}`,
-  description: `Allow entities with the specified ${propertyType} subfield`,
-  resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
-  paramsSchema: zod.z.object({
-    key: zod.z.string().describe(`Property within the entities ${propertyType} to match on`),
-    value: zod.z.string().optional().describe(`Value of the given property to match on`)
-  }),
-  apply: (resource, { key, value }) => {
-    const foundValue = lodash.get(resource[propertyType], key);
-    if (Array.isArray(foundValue)) {
+const createPropertyRule = (propertyType) =>
+  createCatalogPermissionRule({
+    name: `HAS_${propertyType.toUpperCase()}`,
+    description: `Allow entities with the specified ${propertyType} subfield`,
+    resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
+    paramsSchema: zod.z.object({
+      key: zod.z
+        .string()
+        .describe(`Property within the entities ${propertyType} to match on`),
+      value: zod.z
+        .string()
+        .optional()
+        .describe(`Value of the given property to match on`),
+    }),
+    apply: (resource, { key, value }) => {
+      const foundValue = lodash.get(resource[propertyType], key);
+      if (Array.isArray(foundValue)) {
+        if (value !== void 0) {
+          return foundValue.includes(value);
+        }
+        return foundValue.length > 0;
+      }
       if (value !== void 0) {
-        return foundValue.includes(value);
+        return value === foundValue;
       }
-      return foundValue.length > 0;
-    }
-    if (value !== void 0) {
-      return value === foundValue;
-    }
-    return !!foundValue;
-  },
-  toQuery: ({ key, value }) => ({
-    key: `${propertyType}.${key}`,
-    ...value !== void 0 && { values: [value] }
-  })
-});
+      return !!foundValue;
+    },
+    toQuery: ({ key, value }) => ({
+      key: `${propertyType}.${key}`,
+      ...(value !== void 0 && { values: [value] }),
+    }),
+  });
 
 const hasMetadata = createPropertyRule("metadata");
 
@@ -6163,7 +6874,7 @@ const permissionRules = {
   hasMetadata,
   hasSpec,
   isEntityKind,
-  isEntityOwner
+  isEntityOwner,
 };
 
 class AuthorizedEntitiesCatalog {
@@ -6173,61 +6884,86 @@ class AuthorizedEntitiesCatalog {
     this.transformConditions = transformConditions;
   }
   async entities(request) {
-    const authorizeDecision = (await this.permissionApi.authorizeConditional(
-      [{ permission: alpha.catalogEntityReadPermission }],
-      { credentials: request.credentials }
-    ))[0];
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizeDecision = (
+      await this.permissionApi.authorizeConditional(
+        [{ permission: alpha.catalogEntityReadPermission }],
+        { credentials: request.credentials }
+      )
+    )[0];
+    if (
+      authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       return {
         entities: [],
-        pageInfo: { hasNextPage: false }
+        pageInfo: { hasNextPage: false },
       };
     }
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
+    if (
+      authorizeDecision.result ===
+      pluginPermissionCommon.AuthorizeResult.CONDITIONAL
+    ) {
       const permissionFilter = this.transformConditions(
         authorizeDecision.conditions
       );
       return this.entitiesCatalog.entities({
         ...request,
-        filter: (request == null ? void 0 : request.filter) ? { allOf: [permissionFilter, request.filter] } : permissionFilter
+        filter: (request == null ? void 0 : request.filter)
+          ? { allOf: [permissionFilter, request.filter] }
+          : permissionFilter,
       });
     }
     return this.entitiesCatalog.entities(request);
   }
   async entitiesBatch(request) {
-    const authorizeDecision = (await this.permissionApi.authorizeConditional(
-      [{ permission: alpha.catalogEntityReadPermission }],
-      { credentials: request.credentials }
-    ))[0];
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizeDecision = (
+      await this.permissionApi.authorizeConditional(
+        [{ permission: alpha.catalogEntityReadPermission }],
+        { credentials: request.credentials }
+      )
+    )[0];
+    if (
+      authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       return {
-        items: new Array(request.entityRefs.length).fill(null)
+        items: new Array(request.entityRefs.length).fill(null),
       };
     }
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
+    if (
+      authorizeDecision.result ===
+      pluginPermissionCommon.AuthorizeResult.CONDITIONAL
+    ) {
       const permissionFilter = this.transformConditions(
         authorizeDecision.conditions
       );
       return this.entitiesCatalog.entitiesBatch({
         ...request,
-        filter: (request == null ? void 0 : request.filter) ? { allOf: [permissionFilter, request.filter] } : permissionFilter
+        filter: (request == null ? void 0 : request.filter)
+          ? { allOf: [permissionFilter, request.filter] }
+          : permissionFilter,
       });
     }
     return this.entitiesCatalog.entitiesBatch(request);
   }
   async queryEntities(request) {
-    const authorizeDecision = (await this.permissionApi.authorizeConditional(
-      [{ permission: alpha.catalogEntityReadPermission }],
-      { credentials: request.credentials }
-    ))[0];
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizeDecision = (
+      await this.permissionApi.authorizeConditional(
+        [{ permission: alpha.catalogEntityReadPermission }],
+        { credentials: request.credentials }
+      )
+    )[0];
+    if (
+      authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       return {
         items: [],
         pageInfo: {},
-        totalItems: 0
+        totalItems: 0,
       };
     }
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
+    if (
+      authorizeDecision.result ===
+      pluginPermissionCommon.AuthorizeResult.CONDITIONAL
+    ) {
       const permissionFilter = this.transformConditions(
         authorizeDecision.conditions
       );
@@ -6239,13 +6975,17 @@ class AuthorizedEntitiesCatalog {
           ...request,
           cursor: {
             ...request.cursor,
-            filter: request.cursor.filter ? { allOf: [permissionFilter, request.cursor.filter] } : permissionFilter
-          }
+            filter: request.cursor.filter
+              ? { allOf: [permissionFilter, request.cursor.filter] }
+              : permissionFilter,
+          },
         };
       } else {
         permissionedRequest = {
           ...request,
-          filter: request.filter ? { allOf: [permissionFilter, request.filter] } : permissionFilter
+          filter: request.filter
+            ? { allOf: [permissionFilter, request.filter] }
+            : permissionFilter,
         };
         requestFilter = request.filter;
       }
@@ -6254,54 +6994,71 @@ class AuthorizedEntitiesCatalog {
       );
       const prevCursor = response.pageInfo.prevCursor && {
         ...response.pageInfo.prevCursor,
-        filter: requestFilter
+        filter: requestFilter,
       };
       const nextCursor = response.pageInfo.nextCursor && {
         ...response.pageInfo.nextCursor,
-        filter: requestFilter
+        filter: requestFilter,
       };
       return {
         ...response,
         pageInfo: {
           prevCursor,
-          nextCursor
-        }
+          nextCursor,
+        },
       };
     }
     return this.entitiesCatalog.queryEntities(request);
   }
   async removeEntityByUid(uid, options) {
-    const authorizeResponse = (await this.permissionApi.authorizeConditional(
-      [{ permission: alpha.catalogEntityDeletePermission }],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizeResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizeResponse = (
+      await this.permissionApi.authorizeConditional(
+        [{ permission: alpha.catalogEntityDeletePermission }],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizeResponse.result === pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       throw new errors.NotAllowedError();
     }
-    if (authorizeResponse.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
+    if (
+      authorizeResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.CONDITIONAL
+    ) {
       const permissionFilter = this.transformConditions(
         authorizeResponse.conditions
       );
       const { entities } = await this.entitiesCatalog.entities({
         credentials: options.credentials,
         filter: {
-          allOf: [permissionFilter, basicEntityFilter({ "metadata.uid": uid })]
-        }
+          allOf: [permissionFilter, basicEntityFilter({ "metadata.uid": uid })],
+        },
       });
       if (entities.length === 0) {
         throw new errors.NotAllowedError();
       }
     }
     return this.entitiesCatalog.removeEntityByUid(uid, {
-      credentials: options.credentials
+      credentials: options.credentials,
     });
   }
   async entityAncestry(entityRef, options) {
-    const rootEntityAuthorizeResponse = (await this.permissionApi.authorize(
-      [{ permission: alpha.catalogEntityReadPermission, resourceRef: entityRef }],
-      { credentials: options.credentials }
-    ))[0];
-    if (rootEntityAuthorizeResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const rootEntityAuthorizeResponse = (
+      await this.permissionApi.authorize(
+        [
+          {
+            permission: alpha.catalogEntityReadPermission,
+            resourceRef: entityRef,
+          },
+        ],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      rootEntityAuthorizeResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       throw new errors.NotAllowedError();
     }
     const ancestryResult = await this.entitiesCatalog.entityAncestry(
@@ -6311,12 +7068,14 @@ class AuthorizedEntitiesCatalog {
     const authorizeResponse = await this.permissionApi.authorize(
       ancestryResult.items.map((item) => ({
         permission: alpha.catalogEntityReadPermission,
-        resourceRef: catalogModel.stringifyEntityRef(item.entity)
+        resourceRef: catalogModel.stringifyEntityRef(item.entity),
       })),
       { credentials: options.credentials }
     );
     const unauthorizedAncestryItems = ancestryResult.items.filter(
-      (_, index) => authorizeResponse[index].result === pluginPermissionCommon.AuthorizeResult.DENY
+      (_, index) =>
+        authorizeResponse[index].result ===
+        pluginPermissionCommon.AuthorizeResult.DENY
     );
     if (unauthorizedAncestryItems.length === 0) {
       return ancestryResult;
@@ -6325,8 +7084,8 @@ class AuthorizedEntitiesCatalog {
       (ancestryItem) => catalogModel.stringifyEntityRef(ancestryItem.entity)
     );
     const allUnauthorizedEntityRefs = new Set(
-      rootUnauthorizedEntityRefs.flatMap(
-        (rootEntityRef) => this.findParents(
+      rootUnauthorizedEntityRefs.flatMap((rootEntityRef) =>
+        this.findParents(
           rootEntityRef,
           ancestryResult.items,
           new Set(rootUnauthorizedEntityRefs)
@@ -6336,48 +7095,60 @@ class AuthorizedEntitiesCatalog {
     return {
       rootEntityRef: ancestryResult.rootEntityRef,
       items: ancestryResult.items.filter(
-        (ancestryItem) => !allUnauthorizedEntityRefs.has(
-          catalogModel.stringifyEntityRef(ancestryItem.entity)
-        )
-      )
+        (ancestryItem) =>
+          !allUnauthorizedEntityRefs.has(
+            catalogModel.stringifyEntityRef(ancestryItem.entity)
+          )
+      ),
     };
   }
   async facets(request) {
-    const authorizeDecision = (await this.permissionApi.authorizeConditional(
-      [{ permission: alpha.catalogEntityReadPermission }],
-      { credentials: request.credentials }
-    ))[0];
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizeDecision = (
+      await this.permissionApi.authorizeConditional(
+        [{ permission: alpha.catalogEntityReadPermission }],
+        { credentials: request.credentials }
+      )
+    )[0];
+    if (
+      authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       return {
-        facets: Object.fromEntries(request.facets.map((f) => [f, []]))
+        facets: Object.fromEntries(request.facets.map((f) => [f, []])),
       };
     }
-    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
+    if (
+      authorizeDecision.result ===
+      pluginPermissionCommon.AuthorizeResult.CONDITIONAL
+    ) {
       const permissionFilter = this.transformConditions(
         authorizeDecision.conditions
       );
       return this.entitiesCatalog.facets({
         ...request,
-        filter: (request == null ? void 0 : request.filter) ? { allOf: [permissionFilter, request.filter] } : permissionFilter
+        filter: (request == null ? void 0 : request.filter)
+          ? { allOf: [permissionFilter, request.filter] }
+          : permissionFilter,
       });
     }
     return this.entitiesCatalog.facets(request);
   }
   findParents(entityRef, allAncestryItems, seenEntityRefs) {
     const entity = allAncestryItems.find(
-      (ancestryItem) => catalogModel.stringifyEntityRef(ancestryItem.entity) === entityRef
+      (ancestryItem) =>
+        catalogModel.stringifyEntityRef(ancestryItem.entity) === entityRef
     );
-    if (!entity)
-      return [];
+    if (!entity) return [];
     const newSeenEntityRefs = new Set(seenEntityRefs);
-    entity.parentEntityRefs.forEach(
-      (parentRef) => newSeenEntityRefs.add(parentRef)
+    entity.parentEntityRefs.forEach((parentRef) =>
+      newSeenEntityRefs.add(parentRef)
     );
     return [
       entityRef,
-      ...entity.parentEntityRefs.flatMap(
-        (parentRef) => seenEntityRefs.has(parentRef) ? [] : this.findParents(parentRef, allAncestryItems, newSeenEntityRefs)
-      )
+      ...entity.parentEntityRefs.flatMap((parentRef) =>
+        seenEntityRefs.has(parentRef)
+          ? []
+          : this.findParents(parentRef, allAncestryItems, newSeenEntityRefs)
+      ),
     ];
   }
 }
@@ -6388,51 +7159,76 @@ class AuthorizedLocationService {
     this.permissionApi = permissionApi;
   }
   async createLocation(spec, dryRun, options) {
-    const authorizationResponse = (await this.permissionApi.authorize(
-      [{ permission: alpha.catalogLocationCreatePermission }],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizationResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizationResponse = (
+      await this.permissionApi.authorize(
+        [{ permission: alpha.catalogLocationCreatePermission }],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizationResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       throw new errors.NotAllowedError();
     }
     return this.locationService.createLocation(spec, dryRun, options);
   }
   async listLocations(options) {
-    const authorizationResponse = (await this.permissionApi.authorize(
-      [{ permission: alpha.catalogLocationReadPermission }],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizationResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizationResponse = (
+      await this.permissionApi.authorize(
+        [{ permission: alpha.catalogLocationReadPermission }],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizationResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       return [];
     }
     return this.locationService.listLocations(options);
   }
   async getLocation(id, options) {
-    const authorizationResponse = (await this.permissionApi.authorize(
-      [{ permission: alpha.catalogLocationReadPermission }],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizationResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizationResponse = (
+      await this.permissionApi.authorize(
+        [{ permission: alpha.catalogLocationReadPermission }],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizationResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       throw new errors.NotFoundError(`Found no location with ID ${id}`);
     }
     return this.locationService.getLocation(id, options);
   }
   async deleteLocation(id, options) {
-    const authorizationResponse = (await this.permissionApi.authorize(
-      [{ permission: alpha.catalogLocationDeletePermission }],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizationResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizationResponse = (
+      await this.permissionApi.authorize(
+        [{ permission: alpha.catalogLocationDeletePermission }],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizationResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       throw new errors.NotAllowedError();
     }
     return this.locationService.deleteLocation(id, options);
   }
   async getLocationByEntity(entityRef, options) {
-    const authorizationResponse = (await this.permissionApi.authorize(
-      [{ permission: alpha.catalogLocationReadPermission }],
-      { credentials: options.credentials }
-    ))[0];
-    if (authorizationResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
+    const authorizationResponse = (
+      await this.permissionApi.authorize(
+        [{ permission: alpha.catalogLocationReadPermission }],
+        { credentials: options.credentials }
+      )
+    )[0];
+    if (
+      authorizationResponse.result ===
+      pluginPermissionCommon.AuthorizeResult.DENY
+    ) {
       throw new errors.NotFoundError();
     }
     return this.locationService.getLocationByEntity(entityRef, options);
@@ -6443,26 +7239,36 @@ async function deleteWithEagerPruningOfChildren(options) {
   const { knex, entityRefs, sourceKey } = options;
   let removedCount = 0;
   for (const refs of lodash__default.default.chunk(entityRefs, 1e3)) {
-    const { orphanEntityRefs } = await findDescendantsThatWouldHaveBeenOrphanedByDeletion({
-      knex: options.knex,
-      refs,
-      sourceKey
-    });
-    for (const refsToDelete of lodash__default.default.chunk(orphanEntityRefs, 1e3)) {
+    const { orphanEntityRefs } =
+      await findDescendantsThatWouldHaveBeenOrphanedByDeletion({
+        knex: options.knex,
+        refs,
+        sourceKey,
+      });
+    for (const refsToDelete of lodash__default.default.chunk(
+      orphanEntityRefs,
+      1e3
+    )) {
       await markEntitiesAffectedByDeletionForStitching({
         knex: options.knex,
-        entityRefs: refsToDelete
+        entityRefs: refsToDelete,
       });
-      await knex.delete().from("refresh_state").whereIn("entity_ref", refsToDelete);
-    }
-    await knex("refresh_state_references").where("source_key", "=", sourceKey).whereIn("target_entity_ref", refs).delete();
+      await knex
+        .delete()
+        .from("refresh_state")
+        .whereIn("entity_ref", refsToDelete);
+    }
+    await knex("refresh_state_references")
+      .where("source_key", "=", sourceKey)
+      .whereIn("target_entity_ref", refs)
+      .delete();
     removedCount += orphanEntityRefs.length;
   }
   return removedCount;
 }
 async function findDescendantsThatWouldHaveBeenOrphanedByDeletion(options) {
   const { knex, refs, sourceKey } = options;
-  const orphans = (
+  const orphans =
     // First find all nodes that can be reached downwards from the roots
     // (deletion targets), including the roots themselves, by traversing
     // down the refresh_state_references table. Note that this query
@@ -6486,79 +7292,120 @@ async function findDescendantsThatWouldHaveBeenOrphanedByDeletion(options) {
     // down to also find R2 and R3. It uses union instead of union all,
     // because it wants to find the set of unique descendants even if
     // the tree has unexpected loops etc.
-    await knex.withRecursive(
-      "descendants",
-      ["entity_ref"],
-      (initial) => initial.select("target_entity_ref").from("refresh_state_references").where("source_key", "=", sourceKey).whereIn("target_entity_ref", refs).union(
-        (recursive) => recursive.select("refresh_state_references.target_entity_ref").from("descendants").join(
-          "refresh_state_references",
-          "descendants.entity_ref",
-          "refresh_state_references.source_entity_ref"
-        )
+    await knex
+      .withRecursive("descendants", ["entity_ref"], (initial) =>
+        initial
+          .select("target_entity_ref")
+          .from("refresh_state_references")
+          .where("source_key", "=", sourceKey)
+          .whereIn("target_entity_ref", refs)
+          .union((recursive) =>
+            recursive
+              .select("refresh_state_references.target_entity_ref")
+              .from("descendants")
+              .join(
+                "refresh_state_references",
+                "descendants.entity_ref",
+                "refresh_state_references.source_entity_ref"
+              )
+          )
       )
-    ).withRecursive(
-      "ancestors",
-      ["source_key", "source_entity_ref", "target_entity_ref", "subject"],
-      (initial) => initial.select(
-        "refresh_state_references.source_key",
-        "refresh_state_references.source_entity_ref",
-        "refresh_state_references.target_entity_ref",
-        "descendants.entity_ref"
-      ).from("descendants").join(
-        "refresh_state_references",
-        "refresh_state_references.target_entity_ref",
-        "descendants.entity_ref"
-      ).union(
-        (recursive) => recursive.select(
-          "refresh_state_references.source_key",
-          "refresh_state_references.source_entity_ref",
-          "refresh_state_references.target_entity_ref",
-          "ancestors.subject"
-        ).from("ancestors").join(
-          "refresh_state_references",
-          "refresh_state_references.target_entity_ref",
-          "ancestors.source_entity_ref"
-        )
+      .withRecursive(
+        "ancestors",
+        ["source_key", "source_entity_ref", "target_entity_ref", "subject"],
+        (initial) =>
+          initial
+            .select(
+              "refresh_state_references.source_key",
+              "refresh_state_references.source_entity_ref",
+              "refresh_state_references.target_entity_ref",
+              "descendants.entity_ref"
+            )
+            .from("descendants")
+            .join(
+              "refresh_state_references",
+              "refresh_state_references.target_entity_ref",
+              "descendants.entity_ref"
+            )
+            .union((recursive) =>
+              recursive
+                .select(
+                  "refresh_state_references.source_key",
+                  "refresh_state_references.source_entity_ref",
+                  "refresh_state_references.target_entity_ref",
+                  "ancestors.subject"
+                )
+                .from("ancestors")
+                .join(
+                  "refresh_state_references",
+                  "refresh_state_references.target_entity_ref",
+                  "ancestors.source_entity_ref"
+                )
+            )
       )
-    ).with(
-      "retained",
-      ["entity_ref"],
-      (notPartOfDeletion) => notPartOfDeletion.select("subject").from("ancestors").whereNotNull("ancestors.source_key").where(
-        (foreignKeyOrRef) => foreignKeyOrRef.where("ancestors.source_key", "!=", sourceKey).orWhereNotIn("ancestors.target_entity_ref", refs)
+      .with("retained", ["entity_ref"], (notPartOfDeletion) =>
+        notPartOfDeletion
+          .select("subject")
+          .from("ancestors")
+          .whereNotNull("ancestors.source_key")
+          .where((foreignKeyOrRef) =>
+            foreignKeyOrRef
+              .where("ancestors.source_key", "!=", sourceKey)
+              .orWhereNotIn("ancestors.target_entity_ref", refs)
+          )
       )
-    ).select("descendants.entity_ref AS entity_ref").from("descendants").leftOuterJoin(
-      "retained",
-      "retained.entity_ref",
-      "descendants.entity_ref"
-    ).whereNull("retained.entity_ref").then((rows) => rows.map((row) => row.entity_ref))
-  );
+      .select("descendants.entity_ref AS entity_ref")
+      .from("descendants")
+      .leftOuterJoin(
+        "retained",
+        "retained.entity_ref",
+        "descendants.entity_ref"
+      )
+      .whereNull("retained.entity_ref")
+      .then((rows) => rows.map((row) => row.entity_ref));
   return { orphanEntityRefs: orphans };
 }
 async function markEntitiesAffectedByDeletionForStitching(options) {
   const { knex, entityRefs } = options;
-  const affectedIds = await knex.select("refresh_state.entity_id AS entity_id").from("relations").join(
-    "refresh_state",
-    "relations.source_entity_ref",
-    "refresh_state.entity_ref"
-  ).whereIn("relations.target_entity_ref", entityRefs).then((rows) => rows.map((row) => row.entity_id));
+  const affectedIds = await knex
+    .select("refresh_state.entity_id AS entity_id")
+    .from("relations")
+    .join(
+      "refresh_state",
+      "relations.source_entity_ref",
+      "refresh_state.entity_ref"
+    )
+    .whereIn("relations.target_entity_ref", entityRefs)
+    .then((rows) => rows.map((row) => row.entity_id));
   for (const ids of lodash__default.default.chunk(affectedIds, 1e3)) {
-    await knex.table("final_entities").update({
-      hash: "force-stitching"
-    }).whereIn("entity_id", ids);
-    await knex.table("refresh_state").update({
-      result_hash: "force-stitching",
-      next_update_at: knex.fn.now()
-    }).whereIn("entity_id", ids);
+    await knex
+      .table("final_entities")
+      .update({
+        hash: "force-stitching",
+      })
+      .whereIn("entity_id", ids);
+    await knex
+      .table("refresh_state")
+      .update({
+        result_hash: "force-stitching",
+        next_update_at: knex.fn.now(),
+      })
+      .whereIn("entity_id", ids);
   }
 }
 
 async function refreshByRefreshKeys(options) {
   const { tx, keys } = options;
-  await tx("refresh_state").whereIn("entity_id", function selectEntityRefs(inner) {
-    inner.whereIn("key", keys).select({
-      entity_id: "refresh_keys.entity_id"
-    }).from("refresh_keys");
-  }).update({ next_update_at: tx.fn.now() });
+  await tx("refresh_state")
+    .whereIn("entity_id", function selectEntityRefs(inner) {
+      inner
+        .whereIn("key", keys)
+        .select({
+          entity_id: "refresh_keys.entity_id",
+        })
+        .from("refresh_keys");
+    })
+    .update({ next_update_at: tx.fn.now() });
 }
 
 const BATCH_SIZE = 50;
@@ -6575,7 +7422,7 @@ class DefaultProviderDatabase {
         },
         {
           // If we explicitly trigger a rollback, don't fail.
-          doNotRejectOnRollback: true
+          doNotRejectOnRollback: true,
         }
       );
       return result;
@@ -6591,7 +7438,7 @@ class DefaultProviderDatabase {
       const removedCount = await deleteWithEagerPruningOfChildren({
         knex: tx,
         entityRefs: toRemove,
-        sourceKey: options.sourceKey
+        sourceKey: options.sourceKey,
       });
       this.options.logger.debug(
         `removed, ${removedCount} entities: ${JSON.stringify(toRemove)}`
@@ -6610,7 +7457,7 @@ class DefaultProviderDatabase {
               errors: "",
               location_key: item.deferred.locationKey,
               next_update_at: tx.fn.now(),
-              last_discovery_at: tx.fn.now()
+              last_discovery_at: tx.fn.now(),
             })),
             BATCH_SIZE
           );
@@ -6618,7 +7465,9 @@ class DefaultProviderDatabase {
             "refresh_state_references",
             chunk.map((item) => ({
               source_key: options.sourceKey,
-              target_entity_ref: catalogModel.stringifyEntityRef(item.deferred.entity)
+              target_entity_ref: catalogModel.stringifyEntityRef(
+                item.deferred.entity
+              ),
             })),
             BATCH_SIZE
           );
@@ -6637,7 +7486,7 @@ class DefaultProviderDatabase {
     if (toUpsert.length) {
       for (const {
         deferred: { entity, locationKey },
-        hash
+        hash,
       } of toUpsert) {
         const entityRef = catalogModel.stringifyEntityRef(entity);
         try {
@@ -6645,7 +7494,7 @@ class DefaultProviderDatabase {
             tx,
             entity,
             hash,
-            locationKey
+            locationKey,
           });
           if (!ok) {
             ok = await insertUnprocessedEntity({
@@ -6653,22 +7502,23 @@ class DefaultProviderDatabase {
               entity,
               hash,
               locationKey,
-              logger: this.options.logger
+              logger: this.options.logger,
             });
           }
-          await tx("refresh_state_references").where("target_entity_ref", entityRef).andWhere({ source_key: options.sourceKey }).delete();
+          await tx("refresh_state_references")
+            .where("target_entity_ref", entityRef)
+            .andWhere({ source_key: options.sourceKey })
+            .delete();
           if (ok) {
-            await tx(
-              "refresh_state_references"
-            ).insert({
+            await tx("refresh_state_references").insert({
               source_key: options.sourceKey,
-              target_entity_ref: entityRef
+              target_entity_ref: entityRef,
             });
           } else {
             const conflictingKey = await checkLocationKeyConflict({
               tx,
               entityRef,
-              locationKey
+              locationKey,
             });
             if (conflictingKey) {
               this.options.logger.warn(
@@ -6695,44 +7545,51 @@ class DefaultProviderDatabase {
         toAdd: [],
         toUpsert: options.added.map((e) => ({
           deferred: e,
-          hash: generateStableHash$1(e.entity)
+          hash: generateStableHash$1(e.entity),
         })),
-        toRemove: options.removed.map((e) => e.entityRef)
+        toRemove: options.removed.map((e) => e.entityRef),
       };
     }
-    const oldRefs = await tx(
-      "refresh_state_references"
-    ).leftJoin("refresh_state", {
-      target_entity_ref: "entity_ref"
-    }).where({ source_key: options.sourceKey }).select({
-      target_entity_ref: "refresh_state_references.target_entity_ref",
-      location_key: "refresh_state.location_key",
-      unprocessed_hash: "refresh_state.unprocessed_hash"
-    });
+    const oldRefs = await tx("refresh_state_references")
+      .leftJoin("refresh_state", {
+        target_entity_ref: "entity_ref",
+      })
+      .where({ source_key: options.sourceKey })
+      .select({
+        target_entity_ref: "refresh_state_references.target_entity_ref",
+        location_key: "refresh_state.location_key",
+        unprocessed_hash: "refresh_state.unprocessed_hash",
+      });
     const items = options.items.map((deferred) => ({
       deferred,
       ref: catalogModel.stringifyEntityRef(deferred.entity),
-      hash: generateStableHash$1(deferred.entity)
+      hash: generateStableHash$1(deferred.entity),
     }));
     const oldRefsSet = new Map(
       oldRefs.map((r) => [
         r.target_entity_ref,
         {
           locationKey: r.location_key,
-          oldEntityHash: r.unprocessed_hash
-        }
+          oldEntityHash: r.unprocessed_hash,
+        },
       ])
     );
     const newRefsSet = new Set(items.map((item) => item.ref));
     const toAdd = new Array();
     const toUpsert = new Array();
-    const toRemove = oldRefs.map((row) => row.target_entity_ref).filter((ref) => !newRefsSet.has(ref));
+    const toRemove = oldRefs
+      .map((row) => row.target_entity_ref)
+      .filter((ref) => !newRefsSet.has(ref));
     for (const item of items) {
       const oldRef = oldRefsSet.get(item.ref);
       const upsertItem = { deferred: item.deferred, hash: item.hash };
       if (!oldRef) {
         toAdd.push(upsertItem);
-      } else if (((_a = oldRef == null ? void 0 : oldRef.locationKey) != null ? _a : void 0) !== ((_b = item.deferred.locationKey) != null ? _b : void 0)) {
+      } else if (
+        ((_a = oldRef == null ? void 0 : oldRef.locationKey) != null
+          ? _a
+          : void 0) !== ((_b = item.deferred.locationKey) != null ? _b : void 0)
+      ) {
         toRemove.push(item.ref);
         toAdd.push(upsertItem);
       } else if (oldRef.oldEntityHash !== item.hash) {
@@ -6757,7 +7614,7 @@ class DefaultCatalogDatabase {
         },
         {
           // If we explicitly trigger a rollback, don't fail.
-          doNotRejectOnRollback: true
+          doNotRejectOnRollback: true,
         }
       );
       return result;
@@ -6773,9 +7630,9 @@ class DefaultCatalogDatabase {
     const entityRefs = new Array();
     let currentRef = entityRef.toLocaleLowerCase("en-US");
     for (let depth = 1; depth <= MAX_ANCESTOR_DEPTH; depth += 1) {
-      const rows = await tx(
-        "refresh_state_references"
-      ).where({ target_entity_ref: currentRef }).select();
+      const rows = await tx("refresh_state_references")
+        .where({ target_entity_ref: currentRef })
+        .select();
       if (rows.length === 0) {
         if (depth === 1) {
           throw new errors.NotFoundError(`Entity ${currentRef} not found`);
@@ -6784,7 +7641,10 @@ class DefaultCatalogDatabase {
           `Entity ${entityRef} has a broken parent reference chain at ${currentRef}`
         );
       }
-      const parentRef = (_a = rows.find((r) => r.source_entity_ref)) == null ? void 0 : _a.source_entity_ref;
+      const parentRef =
+        (_a = rows.find((r) => r.source_entity_ref)) == null
+          ? void 0
+          : _a.source_entity_ref;
       if (!parentRef) {
         return { entityRefs };
       }
@@ -6798,15 +7658,27 @@ class DefaultCatalogDatabase {
   async refresh(txOpaque, options) {
     const tx = txOpaque;
     const { entityRef } = options;
-    const updateResult = await tx("refresh_state").where({ entity_ref: entityRef.toLocaleLowerCase("en-US") }).update({ next_update_at: tx.fn.now() });
+    const updateResult = await tx("refresh_state")
+      .where({ entity_ref: entityRef.toLocaleLowerCase("en-US") })
+      .update({ next_update_at: tx.fn.now() });
     if (updateResult === 0) {
-      throw new errors.NotFoundError(`Failed to schedule ${entityRef} for refresh`);
+      throw new errors.NotFoundError(
+        `Failed to schedule ${entityRef} for refresh`
+      );
     }
   }
 }
 
 var __defProp = Object.defineProperty;
-var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp = (obj, key, value) =>
+  key in obj
+    ? __defProp(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __publicField = (obj, key, value) => {
   __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
   return value;
@@ -6878,7 +7750,7 @@ class CatalogBuilder {
   setProcessingIntervalSeconds(seconds) {
     this.processingInterval = createRandomProcessingInterval({
       minSeconds: seconds,
-      maxSeconds: seconds * 1.5
+      maxSeconds: seconds * 1.5,
     });
     return this;
   }
@@ -6992,7 +7864,7 @@ class CatalogBuilder {
       new FileReaderProcessor(),
       new UrlReaderProcessor({ reader, logger }),
       CodeOwnersProcessor.fromConfig(config, { logger, reader }),
-      new AnnotateLocationEntityProcessor({ integrations })
+      new AnnotateLocationEntityProcessor({ integrations }),
     ];
   }
   /**
@@ -7076,11 +7948,11 @@ class CatalogBuilder {
       logger,
       permissions,
       scheduler,
-      discovery = backendCommon.HostDiscovery.fromConfig(config)
+      discovery = backendCommon.HostDiscovery.fromConfig(config),
     } = this.env;
     const { auth, httpAuth } = backendCommon.createLegacyAuthAdapters({
       ...this.env,
-      discovery
+      discovery,
     });
     const policy = this.buildEntityPolicy();
     const processors = this.buildProcessors();
@@ -7092,21 +7964,21 @@ class CatalogBuilder {
     }
     const stitcher = DefaultStitcher.fromConfig(config, {
       knex: dbClient,
-      logger
+      logger,
     });
     const processingDatabase = new DefaultProcessingDatabase({
       database: dbClient,
       logger,
       refreshInterval: this.processingInterval,
-      eventBroker: this.eventBroker
+      eventBroker: this.eventBroker,
     });
     const providerDatabase = new DefaultProviderDatabase({
       database: dbClient,
-      logger
+      logger,
     });
     const catalogDatabase = new DefaultCatalogDatabase({
       database: dbClient,
-      logger
+      logger,
     });
     const integrations = integration.ScmIntegrations.fromConfig(config);
     const rulesEnforcer = DefaultCatalogRulesEnforcer.fromConfig(config);
@@ -7117,12 +7989,12 @@ class CatalogBuilder {
       logger,
       parser,
       policy,
-      legacySingleProcessorValidation: this.legacySingleProcessorValidation
+      legacySingleProcessorValidation: this.legacySingleProcessorValidation,
     });
     const unauthorizedEntitiesCatalog = new DefaultEntitiesCatalog({
       database: dbClient,
       logger,
-      stitcher
+      stitcher,
     });
     let permissionsService;
     if ("authorizeConditional" in permissions) {
@@ -7131,37 +8003,48 @@ class CatalogBuilder {
       logger.warn(
         "PermissionAuthorizer is deprecated. Please use an instance of PermissionEvaluator instead of PermissionAuthorizer in PluginEnvironment#permissions"
       );
-      permissionsService = pluginPermissionCommon.toPermissionEvaluator(permissions);
+      permissionsService =
+        pluginPermissionCommon.toPermissionEvaluator(permissions);
     }
     const entitiesCatalog = new AuthorizedEntitiesCatalog(
       unauthorizedEntitiesCatalog,
       permissionsService,
       pluginPermissionNode.createConditionTransformer(this.permissionRules)
     );
-    const permissionIntegrationRouter = pluginPermissionNode.createPermissionIntegrationRouter({
-      resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
-      getResources: async (resourceRefs) => {
-        const { entities } = await unauthorizedEntitiesCatalog.entities({
-          credentials: await auth.getOwnServiceCredentials(),
-          filter: {
-            anyOf: resourceRefs.map((resourceRef) => {
-              const { kind, namespace, name } = catalogModel.parseEntityRef(resourceRef);
-              return basicEntityFilter({
-                kind,
-                "metadata.namespace": namespace,
-                "metadata.name": name
-              });
-            })
-          }
-        });
-        const entitiesByRef = lodash.keyBy(entities, catalogModel.stringifyEntityRef);
-        return resourceRefs.map(
-          (resourceRef) => entitiesByRef[catalogModel.stringifyEntityRef(catalogModel.parseEntityRef(resourceRef))]
-        );
-      },
-      permissions: this.permissions,
-      rules: this.permissionRules
-    });
+    const permissionIntegrationRouter =
+      pluginPermissionNode.createPermissionIntegrationRouter({
+        resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
+        getResources: async (resourceRefs) => {
+          const { entities } = await unauthorizedEntitiesCatalog.entities({
+            credentials: await auth.getOwnServiceCredentials(),
+            filter: {
+              anyOf: resourceRefs.map((resourceRef) => {
+                const { kind, namespace, name } =
+                  catalogModel.parseEntityRef(resourceRef);
+                return basicEntityFilter({
+                  kind,
+                  "metadata.namespace": namespace,
+                  "metadata.name": name,
+                });
+              }),
+            },
+          });
+          const entitiesByRef = lodash.keyBy(
+            entities,
+            catalogModel.stringifyEntityRef
+          );
+          return resourceRefs.map(
+            (resourceRef) =>
+              entitiesByRef[
+                catalogModel.stringifyEntityRef(
+                  catalogModel.parseEntityRef(resourceRef)
+                )
+              ]
+          );
+        },
+        permissions: this.permissions,
+        rules: this.permissionRules,
+      });
     const locationStore = new DefaultLocationStore(dbClient);
     const configLocationProvider = new ConfigLocationEntityProvider(config);
     const entityProviders = lodash__default.default.uniqBy(
@@ -7182,12 +8065,19 @@ class CatalogBuilder {
         var _a2;
         (_a2 = this.onProcessingError) == null ? void 0 : _a2.call(this, event);
       },
-      eventBroker: this.eventBroker
+      eventBroker: this.eventBroker,
     });
-    const locationAnalyzer = (_b = this.locationAnalyzer) != null ? _b : new RepoLocationAnalyzer(logger, integrations, this.locationAnalyzers);
+    const locationAnalyzer =
+      (_b = this.locationAnalyzer) != null
+        ? _b
+        : new RepoLocationAnalyzer(
+            logger,
+            integrations,
+            this.locationAnalyzers
+          );
     const locationService = new AuthorizedLocationService(
       new DefaultLocationService(locationStore, orchestrator, {
-        allowedLocationTypes: this.allowedLocationType
+        allowedLocationTypes: this.allowedLocationType,
       }),
       permissionsService
     );
@@ -7205,7 +8095,7 @@ class CatalogBuilder {
       config,
       permissionIntegrationRouter,
       auth,
-      httpAuth
+      httpAuth,
     });
     await connectEntityProviders(providerDatabase, entityProviders);
     return {
@@ -7217,24 +8107,26 @@ class CatalogBuilder {
         async stop() {
           await processingEngine.stop();
           await stitcher.stop();
-        }
+        },
       },
-      router
+      router,
     };
   }
   subscribe(options) {
     this.onProcessingError = options.onProcessingError;
   }
   buildEntityPolicy() {
-    const entityPolicies = this.entityPoliciesReplace ? [new catalogModel.SchemaValidEntityPolicy(), ...this.entityPolicies] : [
-      new catalogModel.SchemaValidEntityPolicy(),
-      new catalogModel.DefaultNamespaceEntityPolicy(),
-      new catalogModel.NoForeignRootFieldsEntityPolicy(),
-      new catalogModel.FieldFormatEntityPolicy(
-        catalogModel.makeValidator(this.fieldFormatValidators)
-      ),
-      ...this.entityPolicies
-    ];
+    const entityPolicies = this.entityPoliciesReplace
+      ? [new catalogModel.SchemaValidEntityPolicy(), ...this.entityPolicies]
+      : [
+          new catalogModel.SchemaValidEntityPolicy(),
+          new catalogModel.DefaultNamespaceEntityPolicy(),
+          new catalogModel.NoForeignRootFieldsEntityPolicy(),
+          new catalogModel.FieldFormatEntityPolicy(
+            catalogModel.makeValidator(this.fieldFormatValidators)
+          ),
+          ...this.entityPolicies,
+        ];
     return catalogModel.EntityPolicies.allOf(entityPolicies);
   }
   buildProcessors() {
@@ -7245,19 +8137,23 @@ class CatalogBuilder {
       json: jsonPlaceholderResolver,
       yaml: yamlPlaceholderResolver,
       text: textPlaceholderResolver,
-      ...this.placeholderResolvers
+      ...this.placeholderResolvers,
     };
     const processors = [
       new PlaceholderProcessor({
         resolvers: placeholderResolvers,
         reader,
-        integrations
-      })
+        integrations,
+      }),
     ];
     const builtinKindsEntityProcessor = new BuiltinKindsEntityProcessor();
-    if (!this.processors.some(
-      (processor) => processor.getProcessorName() === builtinKindsEntityProcessor.getProcessorName()
-    )) {
+    if (
+      !this.processors.some(
+        (processor) =>
+          processor.getProcessorName() ===
+          builtinKindsEntityProcessor.getProcessorName()
+      )
+    ) {
       processors.push(builtinKindsEntityProcessor);
     }
     if (!this.processorsReplace) {
@@ -7300,11 +8196,20 @@ class CatalogBuilder {
       return;
     }
     const locationTypes = new Set(
-      (_b = (_a = this.env.config.getOptionalConfigArray("catalog.locations")) == null ? void 0 : _a.map((l) => l.getString("type"))) != null ? _b : []
+      (_b =
+        (_a = this.env.config.getOptionalConfigArray("catalog.locations")) ==
+        null
+          ? void 0
+          : _a.map((l) => l.getString("type"))) != null
+        ? _b
+        : []
     );
     const processorNames = new Set(processors.map((p) => p.getProcessorName()));
     function check(locationType, processorName, installationUrl) {
-      if (locationTypes.has(locationType) && !processorNames.has(processorName)) {
+      if (
+        locationTypes.has(locationType) &&
+        !processorNames.has(processorName)
+      ) {
         throw new Error(
           [
             `Your config contains a "catalog.locations" entry of type ${locationType},`,
@@ -7313,7 +8218,7 @@ class CatalogBuilder {
             `external module that has to be installed manually. Please follow the installation`,
             `instructions at ${installationUrl} if you are using this ability, or remove the`,
             `location from your app config if you do not. You can also silence this check entirely`,
-            `by setting the environment variable ${skipCheckVarName} to 'true'.`
+            `by setting the environment variable ${skipCheckVarName} to 'true'.`,
           ].join(" ")
         );
       }
@@ -7369,11 +8274,11 @@ class CatalogBuilder {
     if (!config$1.has(processingIntervalKey)) {
       return createRandomProcessingInterval({
         minSeconds: 100,
-        maxSeconds: 150
+        maxSeconds: 150,
       });
     }
     const duration = config.readDurationFromConfig(config$1, {
-      key: processingIntervalKey
+      key: processingIntervalKey,
     });
     const seconds = Math.max(
       1,
@@ -7381,7 +8286,7 @@ class CatalogBuilder {
     );
     return createRandomProcessingInterval({
       minSeconds: seconds,
-      maxSeconds: seconds * 1.5
+      maxSeconds: seconds * 1.5,
     });
   }
 }
